"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Deployer = void 0;
const Web3 = require("web3");
const TruffleDeployer = require("@truffle/deployer");
const TruffleReporter = require("@truffle/reporters").migrationsV5;
const plugins_1 = require("hardhat/plugins");
const verifier_1 = require("../verifier/verifier");
const constants_1 = require("../constants");
class Deployer {
  constructor(hre, skipVerificationErrors) {
    this.hre = hre;
    this.skipVerificationErrors = skipVerificationErrors;
  }
  async startMigration(logger, verify, confirmations, attempts) {
    try {
      const web3 = new Web3(this.hre.network.provider);
      const chainId = await web3.eth.getChainId();
      const networkType = await web3.eth.net.getNetworkType();
      this.reporter = new TruffleReporter();
      this.deployer = new TruffleDeployer({
        logger: logger,
        confirmations: confirmations,
        provider: web3.currentProvider,
        networks: { chainId: networkType },
        network: "",
        network_id: chainId,
      });
      if (verify) {
        this.verifier = new verifier_1.Verifier(
          this.hre,
          attempts,
          this.skipVerificationErrors
        );
      }
      this.reporter.confirmations = confirmations;
      this.reporter.setMigration({ dryRun: false });
      this.reporter.setDeployer(this.deployer);
      this.reporter.listen();
      this.deployer.start();
      this.reporter.preMigrate({
        isFirst: true,
        file: "Contracts:",
        network: networkType,
        networkId: chainId,
        blockLimit: (await web3.eth.getBlock("latest")).gasLimit,
      });
    } catch (e) {
      throw new plugins_1.NomicLabsHardhatPluginError(
        constants_1.pluginName,
        e.message
      );
    }
  }
  async link(Library, ...Contracts) {
    try {
      const library = Library.contractName ? await Library.deployed() : Library;
      for (const Contract of Contracts) {
        this.reporter.linking({
          libraryName: Library.contractName,
          libraryAddress: Library.address,
          contractName: Contract.contractName,
          contractAddress: Contract.contractAddress,
        });
        await Contract.link(library);
      }
    } catch (e) {
      throw new plugins_1.NomicLabsHardhatPluginError(
        constants_1.pluginName,
        e.message
      );
    }
  }
  async deploy(Instance, ...args) {
    let instance;
    try {
      instance = await this.deployer.deploy(Instance, ...args);
      Instance.setAsDeployed(instance);
      if (this.verifier) {
        await this.verifier.verifySingle(instance, ...args);
      }
      return instance;
    } catch (e) {
      throw new plugins_1.NomicLabsHardhatPluginError(
        constants_1.pluginName,
        e.message
      );
    }
  }
  async deployProxy(Instance, implementationAddress, ...args) {
    let instance;
    try {
      instance = await this.deployer.deploy(Instance, ...args);
      Instance.setAsDeployed(instance);
      if (this.verifier) {
        await this.verifier.verifyProxy(
          instance.address,
          implementationAddress
        );
      }
      return instance;
    } catch (e) {
      throw new plugins_1.NomicLabsHardhatPluginError(
        constants_1.pluginName,
        e.message
      );
    }
  }
  async finishMigration(logger) {
    try {
      this.reporter.postMigrate({
        isLast: true,
      });
      logger.summary();
      this.deployer.finish();
    } catch (e) {
      throw new plugins_1.NomicLabsHardhatPluginError(
        constants_1.pluginName,
        e.message
      );
    }
  }
}
exports.Deployer = Deployer;
//# sourceMappingURL=deployer.js.map
