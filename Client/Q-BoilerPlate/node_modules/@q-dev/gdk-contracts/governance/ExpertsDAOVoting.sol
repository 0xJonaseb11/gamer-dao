// SPDX-License-Identifier: LGPL-3.0-or-later
pragma solidity 0.8.19;

import "./GeneralDAOVoting.sol";

import "../DAO/DAOMemberStorage.sol";

/**
 * @title ExpertsDAOVoting
 * @dev Implementation of contract that manages voting for a DAO panel.
 *
 * With this contract you could create proposals to change parameter or to add some new members to the DAO.
 *
 * ## Example
 *
 * Imagine that you have two panels, one Main panel (it is similar to the Q Constitution Parameters)
 * and one Expert panel (continuing analogy, similar to this Q DeFi Risk Expert Panel Parameters)
 *
 * And so one of the users wanted to create a vote.
 *
 * -- Technical Stuff --
 * In this implementation, votes were divided into two large blocks: RESTRICTED, NON_RESTRICTED and PARTIALLY_RESTRICTED.
 *
 * A NON_RESTRICTED voting it is like Constitution Update or General Q Update, so everyone could
 * create a proposal to change the parameters (in the case of the Constitution Update Proposal)
 * or to rise some other topic (in the case of General Q Update Proposal)
 *
 * A RESTRICTED voting it is like Emergency Update or Parameter Vote for the Expert Proposal,
 * where only an eligible account can create a proposal.
 *
 * -- User Experience --
 *
 * So if user want to create voting for NON_RESTRICTED voting, he could easily achieve it,
 * but it is mandatory for him to deposit some tokens to the DAO
 *
 * With Restricted Voting it's straightforward: only those experts can create a voting and to vote.
 *
 * -- How it implemented --
 *
 * In this implementation voting situation exists, each voting situation are configured by basic parameters
 * for voting, such as time periods, required majority, etc. and also voting type that could be
 * 0 (NON_RESTRICTED), 1 (RESTRICTED), 2 (PARTIALLY_RESTRICTED).
 *
 * As a result, we could create several voting situation for one voting, as a result distinguish
 * between different situation that requires either only experts involvement or community.
 */
contract ExpertsDAOVoting is GeneralDAOVoting {
    DAOMemberStorage public daoMemberStorage;

    /**
     *  @notice The function that will be called from the MasterDAOFactory to inject dependencies.
     *  @param registryAddress_ the registry to pull dependencies from
     */
    function setDependencies(
        address registryAddress_,
        bytes calldata data_
    ) public override dependant {
        super.setDependencies(registryAddress_, data_);

        daoMemberStorage = DAOMemberStorage(daoRegistry.getDAOMemberStorage(targetPanel));
    }

    function _getAndLockUserVotingPower(uint256 proposalId_) internal override returns (uint256) {
        if (proposals[proposalId_].params.votingType == VotingType.RESTRICTED) {
            return 1;
        }

        return super._getAndLockUserVotingPower(proposalId_);
    }

    function _checkRestriction() internal view override {
        require(
            permissionManager.hasPermission(msg.sender, DAO_VOTING_RESOURCE, EXPERT_PERMISSION),
            "[QGDK-017000]-Permission denied - only experts have access."
        );
    }

    function _isRestrictedVotingPassed(
        DAOProposal storage proposal_
    ) internal view override returns (bool) {
        bool isRestricted_ = proposal_.params.votingType == VotingType.RESTRICTED;
        bool isExpertsCountNotZero_ = _getExpertsCount() != 0;
        bool isQuorumReached_ = _getCurrentQuorum(proposal_) > proposal_.params.requiredQuorum;
        bool isMajorityReached_ = _calculatePercentage(
            proposal_.counters.votedFor,
            _getExpertsCount()
        ) > proposal_.params.requiredMajority;
        bool isVetoMembersExists_ = permissionManager.getVetoMembersCount(proposal_.target) > 0;

        if (
            isRestricted_ &&
            isExpertsCountNotZero_ &&
            isQuorumReached_ &&
            isMajorityReached_ &&
            !isVetoMembersExists_
        ) {
            return true;
        }

        return false;
    }

    function _getCurrentQuorum(
        DAOProposal storage proposal_
    ) internal view override returns (uint256) {
        uint256 votesCount_ = proposal_.counters.votedFor + proposal_.counters.votedAgainst;

        if (proposal_.params.votingType == VotingType.RESTRICTED) {
            return _calculatePercentage(votesCount_, _getExpertsCount());
        }

        return super._getCurrentQuorum(proposal_);
    }

    function _getExpertsCount() private view returns (uint256) {
        return daoMemberStorage.getMembers().length;
    }
}
