// SPDX-License-Identifier: LGPL-3.0-or-later
pragma solidity 0.8.19;

import "@dlsl/dev-modules/contracts-registry/pools/pool-factory/AbstractPoolFactory.sol";

import "../interfaces/factory/IMasterDAOFactory.sol";
import "../interfaces/IPermissionManager.sol";
import "../interfaces/IDAOVoting.sol";

import "../DAO/DAOVault.sol";
import "../DAO/DAORegistry.sol";
import "../DAO/DAOMemberStorage.sol";
import "../DAO/DAOParameterStorage.sol";

import "../factory/token/TokenRegistry.sol";
import "../factory/voting/VotingRegistry.sol";

import "./MasterAccessManagement.sol";
import "./MasterDAORegistry.sol";

import "../libs/Parameters.sol";
import "../libs/ArrayHelper.sol";
import "../libs/StringHelper.sol";

import "./Globals.sol";

/**
 * @title MasterDAOFactory
 * @dev This contract is responsible for deploying DAOs and DAO modules.
 * It is the main module of the system. It deploys and initializes the DAO,
 * also through this contract new DAO Expert panels could be deployed and veto groups configured.
 *
 * The is not a final version of contract, so the DAO deployment workflow could change.
 *
 * In theory, you could interact with this contract directly, but it is not recommended.
 * The recommended way is to use [SDK](https://gitlab.com/q-dev/q-gdk/gdk-sdk)
 */
contract MasterDAOFactory is IMasterDAOFactory, AbstractPoolFactory {
    using ArrayHelper for *;
    using StringHelper for string;

    string public constant MASTER_DAO_FACTORY_RESOURCE = "MASTER_DAO_FACTORY_RESOURCE";

    MasterAccessManagement public masterAccess;
    MasterDAORegistry public masterDAORegistry;

    mapping(address => bool) public isDAOVetoConfigured;

    modifier onlyConfDAOPermission(DAORegistry dao_) {
        _requireDAOPermission(dao_, CONFIGURE_DAO_PERMISSION);
        _;
    }

    modifier onlyCreatePermission() {
        _requirePermission(CREATE_PERMISSION);
        _;
    }

    /**
     *  @notice The function that will be called from the MasterDAOFactory to inject dependencies.
     *  @param registryAddress_ the registry to pull dependencies from
     *  @param data_ the extra data that might provide additional context
     */
    function setDependencies(address registryAddress_, bytes calldata data_) public override {
        super.setDependencies(registryAddress_, data_);

        MasterContractsRegistry registry_ = MasterContractsRegistry(registryAddress_);

        masterAccess = MasterAccessManagement(registry_.getPermissionManager());
        masterDAORegistry = MasterDAORegistry(registry_.getMasterDAORegistry());
    }

    /**
     * @inheritdoc IMasterDAOFactory
     */
    function deployDAO(
        DAOConstructorParameters calldata params_
    ) external override returns (address) {
        require(
            params_.votingNames.length == params_.votingAddresses.length,
            "[QGDK-002000]-The length for votingNames and votingAddresses arrays is different."
        );

        string memory moduleType_ = DAO_REGISTRY_NAME;

        address daoRegistryProxy_ = _deploy(address(masterDAORegistry), moduleType_);

        string memory daoRegistryResource_ = getDAOResource(moduleType_, daoRegistryProxy_);

        address permissionManager_ = masterDAORegistry.getImplementation(
            DAO_PERMISSION_MANAGER_NAME
        );

        DAORegistry dao_ = DAORegistry(daoRegistryProxy_);

        dao_.__DAORegistry_init(
            permissionManager_,
            address(this),
            DAO_RESERVED_NAME,
            daoRegistryResource_,
            params_.daoURI
        );

        string[] memory confPermissions_ = [CONFIGURE_DAO_PERMISSION].asArray();

        PermissionManager manager_ = PermissionManager(dao_.getPermissionManager());

        manager_.addPermissionsToRole(
            getDAOCreatorRole(MASTER_DAO_FACTORY_RESOURCE)[0],
            [IRBAC.ResourceWithPermissions(MASTER_DAO_FACTORY_RESOURCE, confPermissions_)]
                .asArray(),
            true
        );

        manager_.grantRoles(params_.masterAccess, getDAOCreatorRole(MASTER_DAO_FACTORY_RESOURCE));

        _register(address(masterDAORegistry), moduleType_, daoRegistryProxy_);

        _deployDAOVault(dao_);
        _deployVotingFactoryAndRegistry(dao_, params_.votingNames, params_.votingAddresses);

        DAOPanelConstructorParameters memory daoPanelParams_ = params_.mainPanelParams;
        daoPanelParams_.votingParams.panelName = DAO_RESERVED_NAME;

        (address daoParameterStorage_, ) = _deployGeneralDAOContracts(
            dao_,
            GENERAL_VOTING_NAME,
            DAO_CONF_PARAMETER_STORAGE_NAME,
            daoPanelParams_
        );

        DAOParameterStorage(daoParameterStorage_).setDAOParameters(
            daoPanelParams_.initialParameters
        );

        // Add address of the DAO Registry to Registry to be able to retrieve it by name
        // Used in the voting situations
        dao_.addContract(DAO_REGISTRY_NAME, daoRegistryProxy_);

        emit DeployedDAORegistry(daoRegistryProxy_, params_);

        emit DeployedPermissionManager(address(manager_), dao_);

        return daoRegistryProxy_;
    }

    /**
     * @inheritdoc IMasterDAOFactory
     */
    function deployDAOPanel(
        DAORegistry dao_,
        DAOPanelConstructorParameters memory daoPanelParams_
    ) public override onlyConfDAOPermission(dao_) returns (address, address, address, address) {
        require(
            !daoPanelParams_.votingParams.panelName.compare(DAO_RESERVED_NAME),
            "[QGDK-002001]-The panel name is reserved."
        );

        require(
            dao_.isAbleToAddPanel(),
            "[QGDK-002002]-The number of DAO panels has exceeded the limit."
        );

        (
            address daoConfParameterStorage_,
            address daoRegParameterStorage_,
            address daoMemberStorage_,
            address voting_
        ) = _deployDAOPanelModules(dao_, daoPanelParams_);

        emit DeployedDAOPanelVoting(voting_, dao_);

        return (daoConfParameterStorage_, daoRegParameterStorage_, daoMemberStorage_, voting_);
    }

    /**
     * @inheritdoc IMasterDAOFactory
     */
    function configureVetoGroups(
        DAORegistry dao_,
        IPermissionManager.VetoGroup[] memory vetoGroups_
    ) external override onlyConfDAOPermission(dao_) {
        require(
            !isDAOVetoConfigured[address(dao_)],
            "[QGDK-002003]-The DAO veto groups has already been configured."
        );

        PermissionManager(dao_.getPermissionManager()).addVetoGroups(vetoGroups_);

        isDAOVetoConfigured[address(dao_)] = true;
    }

    /**
     * @inheritdoc IMasterDAOFactory
     */
    function restoreRegistryPools(
        string calldata name_,
        address[] calldata pools_
    ) external override onlyCreatePermission {
        for (uint256 i = 0; i < pools_.length; i++) {
            masterDAORegistry.addProxyPool(name_, pools_[i]);
        }
    }

    /**
     * @inheritdoc IMasterDAOFactory
     */
    function revokeDAOCreatorRole(DAORegistry dao_) external override onlyConfDAOPermission(dao_) {
        PermissionManager(dao_.getPermissionManager()).revokeRoles(
            msg.sender,
            getDAOCreatorRole(MASTER_DAO_FACTORY_RESOURCE)
        );
    }

    function _deployDAOVault(DAORegistry dao_) private {
        string memory moduleType_ = DAO_VAULT_NAME;

        address daoVaultProxy_ = _deploy(address(masterDAORegistry), moduleType_);

        PermissionManager(dao_.getPermissionManager()).grantRoles(
            daoVaultProxy_,
            MASTER_ROLE.asArray()
        );

        dao_.addContract(DAO_VAULT_NAME, daoVaultProxy_);

        DAOVault(payable(daoVaultProxy_)).__DAOVault_init(dao_);

        _register(address(masterDAORegistry), moduleType_, daoVaultProxy_);

        _injectDAODependencies(address(dao_), address(masterDAORegistry), daoVaultProxy_);

        emit DeployedDAOVault(daoVaultProxy_, dao_);
    }

    function _deployDAOPanelModules(
        DAORegistry dao_,
        DAOPanelConstructorParameters memory daoPanelParams_
    ) private returns (address, address, address, address) {
        dao_.addPanel(daoPanelParams_.votingParams.panelName);

        DAOMemberStorage daoMemberStorage_ = _deployDAOMemberStorage(
            dao_,
            daoPanelParams_.votingParams.panelName
        );

        PermissionManager(dao_.getPermissionManager()).grantRoles(
            address(daoMemberStorage_),
            MASTER_ROLE.asArray()
        );

        daoMemberStorage_.addMembers(daoPanelParams_.initialMembers);

        (address daoParameterStorage_, address voting_) = _deployGeneralDAOContracts(
            dao_,
            EXPERTS_VOTING_NAME,
            DAO_CONF_PARAMETER_STORAGE_NAME,
            daoPanelParams_
        );

        DAOParameterStorage daoRegParameterStorage_ = _deployDAOParameterStorage(
            dao_,
            daoPanelParams_.votingParams.panelName,
            DAO_REG_PARAMETER_STORAGE_NAME
        );

        daoRegParameterStorage_.setDAOParameters(daoPanelParams_.initialParameters);

        return (
            daoParameterStorage_,
            address(daoRegParameterStorage_),
            address(daoMemberStorage_),
            voting_
        );
    }

    function _deployGeneralDAOContracts(
        DAORegistry dao_,
        string memory votingName_,
        string memory parameterStorageType_,
        DAOPanelConstructorParameters memory daoPanelParams_
    ) private returns (address, address) {
        DAOParameterStorage daoParameterStorage_ = _deployDAOParameterStorage(
            dao_,
            daoPanelParams_.votingParams.panelName,
            parameterStorageType_
        );

        address voting_ = IVotingFactory(dao_.getVotingFactory()).deployDAOVoting(
            daoPanelParams_.votingParams,
            votingName_
        );

        PermissionManager(dao_.getPermissionManager()).initialConfiguration(
            dao_,
            voting_,
            votingName_,
            daoPanelParams_.votingParams.panelName
        );

        IDAOVoting votingContract_ = IDAOVoting(voting_);
        IDAOVoting.InitialSituation[] memory situations_ = daoPanelParams_.situations;
        for (uint256 i = 0; i < situations_.length; i++) {
            votingContract_.createDAOVotingSituation(situations_[i]);
        }

        return (address(daoParameterStorage_), voting_);
    }

    function _deployVotingFactoryAndRegistry(
        DAORegistry dao_,
        string[] calldata votingNames_,
        address[] calldata votingAddresses_
    ) private {
        string memory factoryType_ = DAO_VOTING_FACTORY_NAME;
        string memory registryType_ = DAO_VOTING_REGISTRY_NAME;

        address votingFactoryProxy_ = _deploy(address(masterDAORegistry), factoryType_);
        address votingRegistryProxy_ = _deploy(address(masterDAORegistry), registryType_);

        PermissionManager(dao_.getPermissionManager()).grantRoles(
            votingFactoryProxy_,
            MASTER_ROLE.asArray()
        );
        PermissionManager(dao_.getPermissionManager()).grantRoles(
            votingRegistryProxy_,
            MASTER_ROLE.asArray()
        );

        dao_.addContract(DAO_VOTING_FACTORY_NAME, votingFactoryProxy_);
        dao_.addContract(DAO_VOTING_REGISTRY_NAME, votingRegistryProxy_);

        _register(address(masterDAORegistry), factoryType_, votingFactoryProxy_);
        _register(address(masterDAORegistry), registryType_, votingRegistryProxy_);

        _injectDAODependencies(address(dao_), address(masterDAORegistry), votingFactoryProxy_);
        _injectDAODependencies(address(dao_), address(masterDAORegistry), votingRegistryProxy_);

        VotingRegistry votingRegistry_ = VotingRegistry(votingRegistryProxy_);
        votingRegistry_.setNewImplementations(votingNames_, votingAddresses_);

        emit DeployedVotingFactory(votingFactoryProxy_, dao_);
        emit DeployedVotingRegistry(votingRegistryProxy_, dao_);
    }

    function _deployDAOParameterStorage(
        DAORegistry dao_,
        string memory panelName_,
        string memory parameterStorageType_
    ) private returns (DAOParameterStorage) {
        address daoParameterStorage_ = masterDAORegistry.getImplementation(
            DAO_PARAMETER_STORAGE_NAME
        );

        string memory daoParameterPanelName_ = getDAOPanelResource(
            parameterStorageType_,
            panelName_
        );

        dao_.addProxyContract(daoParameterPanelName_, daoParameterStorage_);

        DAOParameterStorage parameterStorage_ = DAOParameterStorage(
            dao_.getContract(daoParameterPanelName_)
        );

        parameterStorage_.__DAOParameterStorage_init(daoParameterPanelName_);

        _register(address(masterDAORegistry), parameterStorageType_, address(parameterStorage_));

        _injectDAODependencies(
            address(dao_),
            address(masterDAORegistry),
            address(parameterStorage_)
        );

        emit DeployedDAOParameterStorage(address(parameterStorage_), dao_);

        return parameterStorage_;
    }

    function _deployDAOMemberStorage(
        DAORegistry dao_,
        string memory panelName_
    ) private returns (DAOMemberStorage) {
        address daoMemberStorage_ = masterDAORegistry.getImplementation(DAO_MEMBER_STORAGE_NAME);

        string memory daoMemberPanelName_ = getDAOPanelResource(
            DAO_MEMBER_STORAGE_NAME,
            panelName_
        );

        dao_.addProxyContract(daoMemberPanelName_, daoMemberStorage_);

        DAOMemberStorage memberStorage_ = DAOMemberStorage(dao_.getContract(daoMemberPanelName_));

        string memory memberStorageType_ = DAO_MEMBER_STORAGE_NAME;

        memberStorage_.__DAOMemberStorage_init(panelName_, daoMemberPanelName_);

        _register(address(masterDAORegistry), memberStorageType_, address(memberStorage_));
        _injectDAODependencies(address(dao_), address(masterDAORegistry), address(memberStorage_));

        emit DeployedDAOMemberStorage(address(memberStorage_), dao_);

        return memberStorage_;
    }

    function _injectDAODependencies(
        address daoRegistryProxy_,
        address poolRegistry_,
        address proxy_
    ) private {
        AbstractDependant(proxy_).setDependencies(daoRegistryProxy_, bytes(""));
        AbstractDependant(proxy_).setInjector(poolRegistry_);
    }

    function _requireDAOPermission(DAORegistry dao_, string memory permission_) private view {
        require(
            PermissionManager(dao_.getPermissionManager()).hasPermission(
                msg.sender,
                MASTER_DAO_FACTORY_RESOURCE,
                permission_
            ),
            "[QGDK-002004]-The sender is not allowed to perform the action on the DAO level, access denied."
        );
    }

    function _requirePermission(string memory permission_) internal view {
        require(
            masterAccess.hasPermission(msg.sender, MASTER_DAO_FACTORY_RESOURCE, permission_),
            "[QGDK-002005]-The sender is not allowed to perform the action, access denied."
        );
    }
}
