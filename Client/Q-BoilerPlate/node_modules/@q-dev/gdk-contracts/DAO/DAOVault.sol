// SPDX-License-Identifier: LGPL-3.0-or-later
pragma solidity 0.8.19;

import "@dlsl/dev-modules/libs/data-structures/PriorityQueue.sol";
import "@dlsl/dev-modules/contracts-registry/AbstractDependant.sol";

import "@openzeppelin/contracts/interfaces/IERC20.sol";
import "@openzeppelin/contracts/interfaces/IERC721Enumerable.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "../interfaces/IDAOVault.sol";
import "../interfaces/tokens/IERC5484.sol";

import "../core/Globals.sol";

import "./DAORegistry.sol";
import "./PermissionManager.sol";

import "../libs/TimeLocks.sol";
import "../libs/TokenBalance.sol";

/**
 * @title DAOVault
 * @dev This contract stores and manages tokens for a DAO, enabling users to lock ERC20,
 * ERC721, and Native tokens or authorize with SBT to obtain the DAO Token Holder role.
 *
 * To differentiate between ERC20 and Native tokens, the ETHEREUM_ADDRESS is used in depositNative
 * and depositERC20 functions. For NFT operations, separate functions such as lockNFT,
 * depositNFT, and withdrawNFT are provided.
 *
 * The locking mechanism for ERC20 and Native tokens is simple: the voting contract locks all user
 * tokens currently in the Vault for a specified time. Once the lock period ends, users can
 * withdraw their tokens without needing to remove time-locks in a separate transaction.
 *
 * For NFT and SBT, the process is slightly different. Only one of the user's NFTs is locked
 * for a certain period, and SBT is not locked.
 * The DAO Vault contract checks if a user has SBT, and if so, the user is granted
 * the DAO Token Holder role.
 *
 * Users can only withdraw NFTs after the lock period has passed, or revoke the SBT authorization
 * any time (SBT will be still owned by the user).
 */
contract DAOVault is IDAOVault, Initializable, AbstractDependant {
    using TokenBalance for address;
    using ERC165Checker for address;

    using EnumerableSet for *;

    using PriorityQueue for PriorityQueue.UintQueue;
    using TimeLockHelper for PriorityQueue.UintQueue;

    string public constant DAO_VAULT_RESOURCE = "DAO_VAULT_RESOURCE";

    uint256 public constant MAX_LOCKED_TIME = 365 days;

    string public CONNECTED_DAO_REGISTRY;

    PermissionManager public permissionManager;

    // user => token => total voting power
    mapping(address => mapping(address => uint256)) public userTokenBalance;

    // user => token => locks
    mapping(address => mapping(address => PriorityQueue.UintQueue)) public lockedTokens;

    // token => total supply
    mapping(address => uint256) public tokenBalance;

    // user => sum of all tokens
    mapping(address => EnumerableSet.AddressSet) internal _userTokens;

    // user => token => tokenIds
    mapping(address => mapping(address => EnumerableSet.UintSet)) internal _userNFTs;

    modifier onlyUpdatePermission() {
        _requirePermission(UPDATE_PERMISSION);
        _;
    }

    receive() external payable {
        _deposit(ETHEREUM_ADDRESS, msg.value);
    }

    /**
     * @notice Initializes the contract.
     *
     * By logic, there is only one DAOVault per DAO, so to make it unique, we connect it with the DAORegistry resource.
     */
    function __DAOVault_init(DAORegistry dao_) external initializer {
        CONNECTED_DAO_REGISTRY = dao_.DAO_REGISTRY_RESOURCE();
    }

    /**
     * @inheritdoc AbstractDependant
     */
    function setDependencies(
        address registryAddress_,
        bytes calldata
    ) external override dependant {
        DAORegistry registry_ = DAORegistry(registryAddress_);

        permissionManager = PermissionManager(registry_.getPermissionManager());
    }

    /**
     * @inheritdoc IDAOVault
     */
    function depositNative() external payable override {
        _deposit(ETHEREUM_ADDRESS, msg.value);
    }

    /**
     * @inheritdoc IDAOVault
     */
    function depositERC20(address tokenAddress_, uint256 amount_) public override {
        IERC20(tokenAddress_).transferFrom(msg.sender, address(this), amount_);

        _deposit(tokenAddress_, amount_);
    }

    /**
     * @inheritdoc IDAOVault
     */
    function depositNFT(address tokenAddress_, uint256 tokenId_) public override {
        require(isSupportedNFT(tokenAddress_), "[QGDK-007000]-The token does not supported.");

        IERC721(tokenAddress_).transferFrom(msg.sender, address(this), tokenId_);

        _userTokens[msg.sender].add(tokenAddress_);
        _userNFTs[msg.sender][tokenAddress_].add(tokenId_);

        permissionManager.addUserToGroups(msg.sender, getDAOGroup(CONNECTED_DAO_REGISTRY));

        emit NFTDeposited(tokenAddress_, msg.sender, tokenId_);
    }

    /**
     * @inheritdoc IDAOVault
     */
    function authorizeBySBT(address tokenAddress_) external override {
        require(
            isAuthorizedBySBT(msg.sender, tokenAddress_),
            "[QGDK-007001]-The user is not authorized or token does not supported."
        );

        _userTokens[msg.sender].add(tokenAddress_);

        permissionManager.addUserToGroups(msg.sender, getDAOGroup(CONNECTED_DAO_REGISTRY));

        emit AuthorizedBySBT(tokenAddress_, msg.sender);
    }

    /**
     * @inheritdoc IDAOVault
     */
    function lock(
        address sender_,
        address tokenAddress_,
        uint256 amount_,
        uint256 timeToLock_
    ) external override onlyUpdatePermission {
        require(
            timeToLock_ <= MAX_LOCKED_TIME + block.timestamp,
            "[QGDK-007002]-The lock time is too big."
        );

        if (isSupportedSBT(tokenAddress_)) {
            _SBTAuthorization(sender_, tokenAddress_);

            emit AuthenticatedBySBT(tokenAddress_, sender_);

            return;
        }

        if (isSupportedNFT(tokenAddress_)) {
            _lockNFT(sender_, tokenAddress_, timeToLock_);
            return;
        }

        require(amount_ > 0, "[QGDK-007003]-The amount to lock should be more than 0.");

        _lockTokens(sender_, tokenAddress_, amount_, timeToLock_);

        emit TokensLocked(tokenAddress_, sender_, amount_, timeToLock_);
    }

    /**
     * @inheritdoc IDAOVault
     */
    function withdrawNative(uint256 amount_) external override {
        _withdraw(ETHEREUM_ADDRESS, amount_);
    }

    /**
     * @inheritdoc IDAOVault
     */
    function withdrawERC20(address tokenAddress_, uint256 amount_) external override {
        _withdraw(tokenAddress_, amount_);
    }

    /**
     * @inheritdoc IDAOVault
     */
    function withdrawNFT(address tokenAddress_, uint256 tokenId_) external override {
        require(
            lockedTokens[msg.sender][tokenAddress_].isAbleToWithdrawNFT(tokenId_),
            "[QGDK-007004]-Trying to withdraw locked NFT."
        );

        uint256 userTokenId_ = _userNFTs[msg.sender][tokenAddress_].at(0);
        _userNFTs[msg.sender][tokenAddress_].remove(userTokenId_);

        if (_userNFTs[msg.sender][tokenAddress_].length() == 0) {
            _removeTokenFromUser(tokenAddress_);
        }

        IERC721(tokenAddress_).transferFrom(address(this), msg.sender, userTokenId_);

        emit NFTWithdrew(tokenAddress_, msg.sender, tokenId_);
    }

    /**
     * @inheritdoc IDAOVault
     */
    function revokeSBTAuthorization(address tokenAddress_) external override {
        require(
            isAuthorizedBySBT(msg.sender, tokenAddress_),
            "[QGDK-007005]-The user is not authorized or token does not supported."
        );

        _removeTokenFromUser(tokenAddress_);

        emit SBTAuthorizationRevoked(tokenAddress_, msg.sender);
    }

    /**
     * @inheritdoc IDAOVault
     */
    function getTokenSupply(address tokenAddress_) external view override returns (uint256) {
        if (tokenAddress_ == ETHEREUM_ADDRESS) {
            return tokenBalance[tokenAddress_];
        }

        return IERC20(tokenAddress_).totalSupply();
    }

    /**
     * @inheritdoc IDAOVault
     */
    function getUserVotingPower(
        address userAddress_,
        address tokenAddress_
    ) external view override returns (uint256) {
        if (isSupportedSBT(tokenAddress_)) {
            return IERC721(tokenAddress_).balanceOf(userAddress_) != 0 ? 1 : 0;
        }

        if (isSupportedNFT(tokenAddress_)) {
            return _userNFTs[userAddress_][tokenAddress_].length() > 0 ? 1 : 0;
        }

        return userTokenBalance[userAddress_][tokenAddress_];
    }

    /**
     * @inheritdoc IDAOVault
     */
    function getUserTokens(
        address userAddress_
    ) external view override returns (address[] memory) {
        return _userTokens[userAddress_].values();
    }

    /**
     * @inheritdoc IDAOVault
     */
    function getTimeLockInfo(
        address userAddress_,
        address tokenAddress_
    ) external view returns (TomeLockInfo memory info_) {
        uint256 userTokenBalance_ = userTokenBalance[userAddress_][tokenAddress_];

        (uint256 amount_, uint256 lastEndTime_) = lockedTokens[userAddress_][tokenAddress_]
            .getWithdrawalAmountAndEndTime(userTokenBalance_);

        info_.withdrawalAmount = amount_;
        info_.lockedAmount = userTokenBalance_ - amount_;
        info_.unlockTime = lastEndTime_;
    }

    /**
     * @inheritdoc IDAOVault
     */
    function getUserNFTs(
        address userAddress_,
        address tokenAddress_
    ) external view override returns (uint256[] memory) {
        return _userNFTs[userAddress_][tokenAddress_].values();
    }

    /**
     * @inheritdoc IDAOVault
     */
    function isAuthorizedBySBT(address sender_, address tokenAddress_) public view returns (bool) {
        if (isSupportedSBT(tokenAddress_) && IERC721(tokenAddress_).balanceOf(sender_) != 0) {
            return true;
        }

        return false;
    }

    /**
     * @inheritdoc IDAOVault
     */
    function isSupportedNFT(address tokenAddress_) public view returns (bool) {
        return
            tokenAddress_.supportsInterface(type(IERC721).interfaceId) &&
            tokenAddress_.supportsInterface(type(IERC721Enumerable).interfaceId);
    }

    /**
     * @inheritdoc IDAOVault
     */
    function isSupportedSBT(address tokenAddress_) public view returns (bool) {
        return
            isSupportedNFT(tokenAddress_) &&
            tokenAddress_.supportsInterface(type(IERC5484).interfaceId);
    }

    function _deposit(address tokenAddress_, uint256 amount_) internal {
        _userTokens[msg.sender].add(tokenAddress_);

        userTokenBalance[msg.sender][tokenAddress_] += amount_;
        tokenBalance[tokenAddress_] += amount_;

        permissionManager.addUserToGroups(msg.sender, getDAOGroup(CONNECTED_DAO_REGISTRY));

        lockedTokens[msg.sender][tokenAddress_].purgeTimeLocks();

        emit TokensDeposited(tokenAddress_, msg.sender, amount_);
    }

    function _SBTAuthorization(address sender_, address tokenAddress_) internal {
        bool isUserHasSBT_ = IERC721(tokenAddress_).balanceOf(sender_) != 0;
        bool isUserHasSBTInVault_ = _userTokens[sender_].contains(tokenAddress_);

        if (isUserHasSBT_ && isUserHasSBTInVault_) {
            return;
        }

        if (!isUserHasSBT_) {
            revert("[QGDK-007006]-The user does not have the SBT token.");
        }

        _userTokens[sender_].add(tokenAddress_);
    }

    function _lockTokens(
        address sender_,
        address tokenAddress_,
        uint256 amount_,
        uint256 timeToLock_
    ) internal {
        require(
            userTokenBalance[sender_][tokenAddress_] >= amount_,
            "[QGDK-007007]-Not enough tokens to lock."
        );

        lockedTokens[sender_][tokenAddress_].purgeTimeLocks();
        lockedTokens[sender_][tokenAddress_].lock(amount_, timeToLock_);
    }

    function _lockNFT(address sender_, address tokenAddress_, uint256 timeToLock_) internal {
        require(_userNFTs[sender_][tokenAddress_].length() > 0, "[QGDK-007008]-No NFT to lock.");

        uint256 userTokenId_ = _userNFTs[sender_][tokenAddress_].at(0);
        lockedTokens[sender_][tokenAddress_].lockNFT(userTokenId_, timeToLock_);

        emit NFTLocked(tokenAddress_, sender_, userTokenId_, timeToLock_);
    }

    function _withdraw(address tokenAddress_, uint256 amount_) internal {
        require(
            lockedTokens[msg.sender][tokenAddress_].isAbleToWithdraw(
                userTokenBalance[msg.sender][tokenAddress_],
                amount_
            ),
            "[QGDK-007009]-Trying to withdraw more than locked."
        );

        require(
            userTokenBalance[msg.sender][tokenAddress_] >= amount_,
            "[QGDK-007010]-Not enough tokens to withdraw."
        );

        if (userTokenBalance[msg.sender][tokenAddress_] - amount_ == 0) {
            _removeTokenFromUser(tokenAddress_);
        }

        userTokenBalance[msg.sender][tokenAddress_] -= amount_;
        tokenBalance[tokenAddress_] -= amount_;

        lockedTokens[msg.sender][tokenAddress_].purgeTimeLocks();

        tokenAddress_.sendFunds(msg.sender, amount_);

        emit TokensWithdrew(tokenAddress_, msg.sender, amount_);
    }

    function _removeTokenFromUser(address tokenAddress_) internal {
        _userTokens[msg.sender].remove(tokenAddress_);

        if (_userTokens[msg.sender].length() == 0) {
            permissionManager.removeUserFromGroups(
                msg.sender,
                getDAOGroup(CONNECTED_DAO_REGISTRY)
            );
        }
    }

    function _requirePermission(string memory permission_) internal view {
        require(
            permissionManager.hasPermission(msg.sender, DAO_VAULT_RESOURCE, permission_),
            "[QGDK-007011]-The sender is not allowed to perform the action, access denied."
        );
    }
}
