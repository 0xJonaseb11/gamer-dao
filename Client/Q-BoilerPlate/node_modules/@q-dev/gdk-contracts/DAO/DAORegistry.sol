// SPDX-License-Identifier: LGPL-3.0-or-later
pragma solidity 0.8.19;

import "@openzeppelin/contracts/utils/Strings.sol";

import "@dlsl/dev-modules/libs/data-structures/StringSet.sol";

import "../metadata/DAOMetadata.sol";

import "../interfaces/IDAORegistry.sol";
import "../interfaces/IDAOMemberStorage.sol";

import "../core/Globals.sol";
import "../core/registry/RoleManagedRegistry.sol";

import "./PermissionManager.sol";
import "./DAOParameterStorage.sol";

/**
 * @title DAORegistry
 * @dev This contract serves as a registry for all DAO contracts and gives permission
 * to update contracts, etc. eligible parties via the permission manager.
 *
 * Currently, the `DAORegistry` contract is just a contract that stores the addresses
 * of the contracts associated with the DAO.
 * When a DAO is created, several contracts are already there (token and voice factories, permission manager, etc.).
 * But it doesn't end there; during its life the DAO may decide to add more functionality,
 * as a result, it will need to add new contracts and be able to manage them through the DAO itself.
 * This can be achieved by playing around with the `PermissionManager' contract and DAO resources.
 *
 * The basic paradigm of the system itself is this:
 *  - All contracts in the system are `resources'.
 *  - Over each resource, you can perform an `action'.
 *
 *
 * From this contract, you can get the addresses of the base modules and a list of panels that
 * currently exist in the DAO.
 *
 * > Currently information on the DAO is stored in the dApp on the frontend side.
 */
contract DAORegistry is IDAORegistry, DAOMetadata, RoleManagedRegistry {
    using Strings for uint256;
    using ParameterCodec for *;
    using StringSet for StringSet.Set;

    string public DAO_REGISTRY_RESOURCE;

    PermissionManager public permissionManager;

    StringSet.Set internal _panels;

    /**
     * @notice Initializes the contract with unique resource, and inits the permission manager,
     * that will be used to manage the permissions for the DAO.
     */
    function __DAORegistry_init(
        address permissionManager_,
        address masterAccess_,
        string calldata panelName_,
        string calldata registryResource_,
        string calldata daoURI_
    ) external initializer {
        __RoleManagedRegistry_init(permissionManager_);
        __DAOMetadata_init(daoURI_);

        permissionManager = PermissionManager(getPermissionManager());

        string memory managerResource_ = getDAOResource(
            DAO_PERMISSION_MANAGER_NAME,
            address(permissionManager)
        );

        DAO_REGISTRY_RESOURCE = registryResource_;

        permissionManager.__PermissionManager_init(
            this,
            masterAccess_,
            managerResource_,
            panelName_
        );

        emit Initialized();
    }

    modifier onlyCreatePermission() override {
        _requirePermission(CREATE_PERMISSION);
        _;
    }

    modifier onlyUpdatePermission() override {
        _requirePermission(UPDATE_PERMISSION);
        _;
    }

    modifier onlyDeletePermission() override {
        _requirePermission(DELETE_PERMISSION);
        _;
    }

    modifier onlyChangeDAOMetadataPermission() override {
        _requirePermission(CHANGE_DAO_METADATA_PERMISSION);
        _;
    }

    /**
     * @inheritdoc IDAOResource
     */
    function checkPermission(
        address account_,
        string memory permission_
    ) public view override returns (bool) {
        return permissionManager.hasPermission(account_, DAO_REGISTRY_RESOURCE, permission_);
    }

    /**
     * @inheritdoc IDAOResource
     */
    function getResource() external view returns (string memory) {
        return DAO_REGISTRY_RESOURCE;
    }

    /**
     * @inheritdoc IDAORegistry
     */
    function addPanel(string calldata panelName_) external override onlyCreatePermission {
        require(_panels.add(panelName_), "DAORegistry: panel already exists in the DAO");

        emit PanelAdded(panelName_);
    }

    /**
     * @inheritdoc IDAORegistry
     */
    function removePanel(string calldata panelName_) external override onlyDeletePermission {
        require(_panels.remove(panelName_), "DAORegistry: panel does not exist in the DAO");

        emit PanelRemoved(panelName_);
    }

    /**
     * @inheritdoc IDAORegistry
     */
    function getPanels() external view override returns (string[] memory) {
        return _panels.values();
    }

    /**
     * @inheritdoc IDAORegistry
     */
    function isAbleToAddPanel() external view override returns (bool) {
        DAOParameterStorage daoParameterStorage_ = DAOParameterStorage(
            getConfDAOParameterStorage(DAO_RESERVED_NAME)
        );

        uint256 panelLimit_ = daoParameterStorage_
            .getDAOParameter(DAO_PANEL_LIMIT_NAME)
            .decodeUint256();

        return _panels.length() < panelLimit_;
    }

    /**
     * @inheritdoc IDAORegistry
     */
    function getAccountStatuses(
        address account_
    ) external view override returns (AccountStatus memory status) {
        string[] memory panels_ = _panels.values();

        string[] memory groups_ = new string[](panels_.length + 1);
        bool[] memory isMember_ = new bool[](panels_.length + 1);

        groups_[0] = "DAO Token Holder";
        isMember_[0] = permissionManager.hasPermission(
            account_,
            DAO_REGISTRY_RESOURCE,
            VOTE_FOR_PERMISSION
        );

        for (uint256 i = 0; i < panels_.length; i++) {
            groups_[i + 1] = getDAOGroup(panels_[i])[0];
            isMember_[i + 1] = permissionManager.hasPermission(
                account_,
                getDAOPanelResource(EXPERTS_VOTING_NAME, panels_[i]),
                EXPERT_PERMISSION
            );
        }

        status.groups = groups_;
        status.isMember = isMember_;
    }

    /**
     * @inheritdoc IDAORegistry
     */
    function getConfDAOParameterStorage(string memory panelName_) public view returns (address) {
        return getContract(getDAOPanelResource(DAO_CONF_PARAMETER_STORAGE_NAME, panelName_));
    }

    /**
     * @inheritdoc IDAORegistry
     */
    function getRegDAOParameterStorage(string memory panelName_) external view returns (address) {
        return getContract(getDAOPanelResource(DAO_REG_PARAMETER_STORAGE_NAME, panelName_));
    }

    /**
     * @inheritdoc IDAORegistry
     */
    function getDAOMemberStorage(string memory panelName_) public view returns (address) {
        return getContract(getDAOPanelResource(DAO_MEMBER_STORAGE_NAME, panelName_));
    }

    /**
     * @inheritdoc IDAORegistry
     */
    function getGeneralDAOVoting(string memory panelName_) public view returns (address) {
        return getContract(getDAOPanelResource(GENERAL_VOTING_NAME, panelName_));
    }

    /**
     * @inheritdoc IDAORegistry
     */
    function getExpertsDAOVoting(string memory panelName_) public view returns (address) {
        return getContract(getDAOPanelResource(EXPERTS_VOTING_NAME, panelName_));
    }

    /**
     * @inheritdoc IDAORegistry
     */
    function getVotingFactory() external view returns (address) {
        return getContract(DAO_VOTING_FACTORY_NAME);
    }

    /**
     * @inheritdoc IDAORegistry
     */
    function getVotingRegistry() external view returns (address) {
        return getContract(DAO_VOTING_REGISTRY_NAME);
    }

    /**
     * @inheritdoc IDAORegistry
     */
    function getDAOVault() external view returns (address) {
        return getContract(DAO_VAULT_NAME);
    }

    function _requirePermission(string memory permission_) internal view {
        require(
            checkPermission(msg.sender, permission_),
            "[QGDK-006000]-The sender is not allowed to perform the action, access denied."
        );
    }
}
