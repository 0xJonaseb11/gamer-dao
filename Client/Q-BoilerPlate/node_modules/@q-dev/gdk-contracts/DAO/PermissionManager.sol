// SPDX-License-Identifier: LGPL-3.0-or-later
pragma solidity 0.8.19;

import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/Multicall.sol";

import "@dlsl/dev-modules/contracts-registry/AbstractDependant.sol";
import "@dlsl/dev-modules/access-control/extensions/RBACGroupable.sol";

import "../interfaces/IDAOIntegration.sol";
import "../interfaces/IPermissionManager.sol";

import "./DAOVault.sol";
import "./DAORegistry.sol";

import "../core/Globals.sol";

import "../libs/ArrayHelper.sol";

/**
 * @title PermissionManager
 * @dev Implementation of contract that manages permissions and roles in a DAO.
 *
 * The contract is based on the RBACGroupable contract.
 * It is the core of whole DAO through which you could permissions to any resources
 * by creating roles, are add specific user to the groups.
 *
 * This module is in developing process and will be improved in the future.
 */
contract PermissionManager is IPermissionManager, Multicall, RBACGroupable {
    using ArrayHelper for *;
    using Strings for uint256;

    using EnumerableSet for EnumerableSet.AddressSet;

    string public PERMISSION_MANAGER_RESOURCE;

    EnumerableSet.AddressSet internal _existingVetoGroupTargets;

    // resource => data about guys who could veto on the resource
    mapping(string => VetoGroup) internal _vetoGroups;

    modifier onlyCreatePermission() {
        _requirePermission(CREATE_PERMISSION);
        _;
    }

    modifier onlyAddGroupPermission() {
        _requirePermission(ADD_GROUP_PERMISSION);
        _;
    }

    modifier onlyUpdateGroupPermission() {
        _requirePermission(UPDATE_GROUP_PERMISSION);
        _;
    }

    modifier onlyDeleteGroupPermission() {
        _requirePermission(DELETE_GROUP_PERMISSION);
        _;
    }

    modifier onlyIntegrationPermission() {
        _requirePermission(INTEGRATION_PERMISSION);
        _;
    }

    /**
     * @notice Initializes the contract.
     * @param master_ the address of the master, who will be able to crate roles and grant permissions to all resources in the DAO.
     */
    function __PermissionManager_init(
        DAORegistry dao_,
        address master_,
        string memory resource_,
        string calldata panelName_
    ) external initializer {
        __RBAC_init();
        _grantRoles(master_, MASTER_ROLE.asArray());
        _grantRoles(address(dao_), MASTER_ROLE.asArray());

        PERMISSION_MANAGER_RESOURCE = resource_;

        string[] memory votingPermissions_ = [
            ADD_GROUP_PERMISSION,
            DELETE_GROUP_PERMISSION,
            ADD_MEMBER_PERMISSION,
            DELETE_MEMBER_PERMISSION,
            INTEGRATION_PERMISSION,
            CHANGE_DAO_METADATA_PERMISSION
        ].asArray();

        addPermissionsToRole(
            getDAOVotingRole(panelName_)[0],
            [IRBAC.ResourceWithPermissions(PERMISSION_MANAGER_RESOURCE, votingPermissions_)]
                .asArray(),
            true
        );

        addPermissionsToRole(
            getDAOVotingRole(panelName_)[0],
            [
                IRBAC.ResourceWithPermissions(
                    dao_.DAO_REGISTRY_RESOURCE(),
                    [CREATE_PERMISSION, UPDATE_PERMISSION, DELETE_PERMISSION].asArray()
                )
            ].asArray(),
            true
        );

        string[] memory memberPermissions_ = [
            CREATE_VOTING_PERMISSION,
            VOTE_FOR_PERMISSION,
            VOTE_PERMISSION
        ].asArray();

        _grantSpecialPermissions(dao_, getDAOMemberRole(panelName_)[0], memberPermissions_);

        string[] memory expertPermissions_ = [EXPERT_PERMISSION].asArray();

        _grantSpecialPermissions(dao_, getDAOExpertRole(panelName_)[0], expertPermissions_);

        grantGroupRoles(
            getDAOGroup(dao_.DAO_REGISTRY_RESOURCE())[0],
            getDAOMemberRole(panelName_)
        );
    }

    /**
     * @inheritdoc IPermissionManager
     */
    function confExternalModule(
        DAORegistry dao_,
        string memory moduleName_
    ) public override onlyIntegrationPermission {
        require(
            dao_.hasContract(moduleName_),
            "[QGDK-008000]-The module not found in the DAO Registry."
        );

        (bool success_, bytes memory result_) = dao_.getContract(moduleName_).staticcall(
            abi.encodeWithSignature("getResourceRecords()")
        );

        require(
            success_ && result_.length > 0,
            "[QGDK-008001]-The target contract must follow integration documentation."
        );

        IDAOIntegration.ResourceRecords[] memory records_ = abi.decode(
            result_,
            (IDAOIntegration.ResourceRecords[])
        );

        for (uint256 i = 0; i < records_.length; i++) {
            _addPermissionsToRole(
                records_[i].existingRole,
                records_[i].resource,
                records_[i].permissions,
                true
            );
        }
    }

    /**
     * @inheritdoc IPermissionManager
     */
    function confVotingModule(
        DAORegistry dao_,
        string memory votingName_,
        address voting_,
        string memory panelName_
    ) external override onlyCreatePermission {
        _confVotingModule(dao_, votingName_, voting_, panelName_);
    }

    /**
     * @inheritdoc IPermissionManager
     */
    function confMemberGroup(
        DAORegistry dao_,
        string memory votingName_,
        string memory panelName_
    ) external override onlyCreatePermission {
        _confMemberGroup(dao_, votingName_, panelName_);
    }

    /**
     * @inheritdoc IPermissionManager
     */
    function confExpertsGroups(
        string memory votingName_,
        string memory panelName_
    ) external override onlyCreatePermission {
        _confExpertsGroups(votingName_, panelName_);
    }

    /**
     * @inheritdoc IPermissionManager
     */
    function initialConfiguration(
        DAORegistry dao_,
        address voting_,
        string memory votingName_,
        string memory panelName_
    ) external override onlyCreatePermission {
        _confVotingModule(dao_, votingName_, voting_, panelName_);
        _confMemberGroup(dao_, votingName_, panelName_);
        _confExpertsGroups(votingName_, panelName_);
    }

    /**
     * @inheritdoc IPermissionManager
     */
    function addVetoGroups(VetoGroup[] memory vetoGroups_) external onlyAddGroupPermission {
        for (uint256 i = 0; i < vetoGroups_.length; i++) {
            _addVetoGroup(
                vetoGroups_[i].target,
                vetoGroups_[i].name,
                vetoGroups_[i].linkedMemberStorage
            );
        }
    }

    /**
     * @inheritdoc IPermissionManager
     */
    function addVetoGroup(
        address target_,
        string memory name_,
        DAOMemberStorage linkedMemberStorage_
    ) external override onlyAddGroupPermission {
        _addVetoGroup(target_, name_, linkedMemberStorage_);
    }

    /**
     * @inheritdoc IPermissionManager
     */
    function removeVetoGroup(address target_) external override onlyDeleteGroupPermission {
        string memory resource_ = _getResourceFromTarget(target_);

        require(
            _vetoGroups[resource_].target != address(0),
            "[QGDK-008002]-The veto group does not exists, impossible to remove it."
        );

        DAOMemberStorage linkedMemberStorage_ = _vetoGroups[resource_].linkedMemberStorage;
        if (address(linkedMemberStorage_) != address(0)) {
            revokeGroupRoles(linkedMemberStorage_.getGroup()[0], getVetoGroupRole(resource_));
        }

        delete _vetoGroups[resource_];

        string[] memory expertPermissions_ = [VETO_FOR_PERMISSION].asArray();

        removePermissionsFromRole(
            getVetoGroupRole(resource_)[0],
            [IRBAC.ResourceWithPermissions(resource_, expertPermissions_)].asArray(),
            true
        );

        revokeGroupRoles(getVetoGroup(resource_)[0], getVetoGroupRole(resource_));

        _existingVetoGroupTargets.remove(target_);

        emit VetoGroupRemoved(target_);
    }

    /**
     * @inheritdoc IPermissionManager
     */
    function linkStorageToVetoGroup(
        address target_,
        DAOMemberStorage linkedMemberStorage_
    ) external override onlyUpdateGroupPermission {
        string memory resource_ = _getResourceFromTarget(target_);

        require(
            _vetoGroups[resource_].target != address(0),
            "[QGDK-008003]-The veto group does not exists, impossible to link it with member storage."
        );

        DAOMemberStorage oldLinkedMemberStorage_ = _vetoGroups[resource_].linkedMemberStorage;
        if (address(oldLinkedMemberStorage_) != address(0)) {
            revokeGroupRoles(oldLinkedMemberStorage_.getGroup()[0], getVetoGroupRole(resource_));
        }

        _vetoGroups[resource_].linkedMemberStorage = linkedMemberStorage_;

        if (address(linkedMemberStorage_) != address(0)) {
            grantGroupRoles(linkedMemberStorage_.getGroup()[0], getVetoGroupRole(resource_));
        }

        emit LinkedStorageToVetoGroup(target_, address(linkedMemberStorage_));
    }

    /**
     * @dev Gets the accounts who could veto a proposal.
     */
    function getVetoGroupMembers(address target_) public view returns (address[] memory) {
        VetoGroup storage vetoGroup_ = _vetoGroups[_getResourceFromTarget(target_)];

        if (address(vetoGroup_.linkedMemberStorage) == address(0)) {
            return new address[](0);
        }

        return vetoGroup_.linkedMemberStorage.getMembers();
    }

    /**
     * @inheritdoc IPermissionManager
     */
    function getVetoMembersCount(address target_) external view override returns (uint256) {
        return getVetoGroupMembers(target_).length;
    }

    /**
     * @inheritdoc IPermissionManager
     */
    function getVetoGroupInfo(address target_) external view override returns (VetoGroup memory) {
        return _vetoGroups[_getResourceFromTarget(target_)];
    }

    /**
     * @inheritdoc IPermissionManager
     */
    function isVetoGroupExists(address target_) external view override returns (bool) {
        return _vetoGroups[_getResourceFromTarget(target_)].target != address(0);
    }

    /**
     * @inheritdoc IPermissionManager
     */
    function getExistingVetoGroupTargets() external view override returns (address[] memory) {
        return _existingVetoGroupTargets.values();
    }

    /**
     * @inheritdoc IDAOResource
     */
    function checkPermission(
        address account_,
        string memory permission_
    ) public view override returns (bool) {
        return hasPermission(account_, PERMISSION_MANAGER_RESOURCE, permission_);
    }

    /**
     * @inheritdoc IDAOResource
     */
    function getResource() external view returns (string memory) {
        return PERMISSION_MANAGER_RESOURCE;
    }

    function _confVotingModule(
        DAORegistry dao_,
        string memory votingName_,
        address voting_,
        string memory panelName_
    ) internal {
        string[] memory votingContractPermissions_ = [
            CREATE_PERMISSION,
            UPDATE_PERMISSION,
            DELETE_PERMISSION
        ].asArray();

        IRBAC.ResourceWithPermissions[] memory toAdd_ = _getResourcesWithPermissionForPanels(
            votingName_,
            votingContractPermissions_,
            panelName_
        );

        addPermissionsToRole(getDAOVotingRole(panelName_)[0], toAdd_, true);

        addPermissionsToRole(
            getDAOVotingRole(panelName_)[0],
            [
                IRBAC.ResourceWithPermissions(
                    DAOVault(payable(dao_.getDAOVault())).DAO_VAULT_RESOURCE(),
                    [UPDATE_PERMISSION].asArray()
                )
            ].asArray(),
            true
        );

        grantRoles(voting_, getDAOVotingRole(panelName_));
    }

    function _confMemberGroup(
        DAORegistry dao_,
        string memory votingName_,
        string memory panelName_
    ) internal {
        string[] memory memberPermissions_ = [
            CREATE_VOTING_PERMISSION,
            VOTE_FOR_PERMISSION,
            VOTE_PERMISSION
        ].asArray();

        IRBAC.ResourceWithPermissions[] memory toAdd_ = _getResourcesWithPermissionForPanels(
            votingName_,
            memberPermissions_,
            panelName_
        );

        addPermissionsToRole(getDAOMemberRole(panelName_)[0], toAdd_, true);

        grantGroupRoles(
            getDAOGroup(dao_.DAO_REGISTRY_RESOURCE())[0],
            getDAOMemberRole(panelName_)
        );
    }

    function _confExpertsGroups(string memory votingName_, string memory panelName_) internal {
        string[] memory expertPermissions_ = [EXPERT_PERMISSION].asArray();

        IRBAC.ResourceWithPermissions[] memory toAdd_ = _getResourcesWithPermissionForPanels(
            votingName_,
            expertPermissions_,
            panelName_
        );

        addPermissionsToRole(getDAOExpertRole(panelName_)[0], toAdd_, true);

        grantGroupRoles(getDAOExpertGroup(panelName_)[0], getDAOExpertRole(panelName_));
    }

    function _addVetoGroup(
        address target_,
        string memory name_,
        DAOMemberStorage linkedMemberStorage_
    ) internal {
        string memory resource_ = _getResourceFromTarget(target_);

        require(
            _vetoGroups[resource_].target == address(0),
            "[QGDK-008004]-The veto group already exists."
        );

        _vetoGroups[resource_].name = name_;
        _vetoGroups[resource_].target = target_;
        _vetoGroups[resource_].linkedMemberStorage = linkedMemberStorage_;

        string[] memory vetoPermissions_ = [VETO_FOR_PERMISSION].asArray();

        addPermissionsToRole(
            getVetoGroupRole(resource_)[0],
            [IRBAC.ResourceWithPermissions(resource_, vetoPermissions_)].asArray(),
            true
        );

        grantGroupRoles(getVetoGroup(resource_)[0], getVetoGroupRole(resource_));

        if (address(linkedMemberStorage_) != address(0)) {
            grantGroupRoles(linkedMemberStorage_.getGroup()[0], getVetoGroupRole(resource_));
        }

        _existingVetoGroupTargets.add(target_);

        emit VetoGroupAdded(target_, name_, address(linkedMemberStorage_));
    }

    function _grantSpecialPermissions(
        DAORegistry dao_,
        string memory role_,
        string[] memory permissions_
    ) private {
        addPermissionsToRole(
            role_,
            [IRBAC.ResourceWithPermissions(PERMISSION_MANAGER_RESOURCE, permissions_)].asArray(),
            true
        );

        addPermissionsToRole(
            role_,
            [IRBAC.ResourceWithPermissions(dao_.DAO_REGISTRY_RESOURCE(), permissions_)].asArray(),
            true
        );
    }

    function _getResourceFromTarget(address target_) private view returns (string memory) {
        (, bytes memory result_) = target_.staticcall(abi.encodeWithSignature("getResource()"));
        require(
            result_.length > 0,
            "[QGDK-008005]-The target contract must implement the IDAOResource interface."
        );

        return abi.decode(result_, (string));
    }

    function _requirePermission(string memory permission_) private view {
        require(
            checkPermission(msg.sender, permission_),
            "[QGDK-008006]-The sender is not allowed to perform the action, access denied."
        );
    }

    function _getResourcesWithPermissionForPanels(
        string memory votingName_,
        string[] memory permissions_,
        string memory panelName_
    ) private pure returns (IRBAC.ResourceWithPermissions[] memory) {
        string memory daoConfParameterPanelResource_ = getDAOPanelResource(
            DAO_CONF_PARAMETER_STORAGE_NAME,
            panelName_
        );

        string memory daoRegParameterPanelResource_ = getDAOPanelResource(
            DAO_REG_PARAMETER_STORAGE_NAME,
            panelName_
        );

        string memory daoMemberPanelResource_ = getDAOPanelResource(
            DAO_MEMBER_STORAGE_NAME,
            panelName_
        );

        string memory daoVotingResource_ = getDAOPanelResource(votingName_, panelName_);

        IRBAC.ResourceWithPermissions memory daoConfParameterStorageResource_ = IRBAC
            .ResourceWithPermissions(daoConfParameterPanelResource_, permissions_);

        IRBAC.ResourceWithPermissions memory daoRegParameterStorageResource_ = IRBAC
            .ResourceWithPermissions(daoRegParameterPanelResource_, permissions_);

        IRBAC.ResourceWithPermissions memory daoMemberStorageResource_ = IRBAC
            .ResourceWithPermissions(daoMemberPanelResource_, permissions_);

        IRBAC.ResourceWithPermissions memory daoVotingRWP_ = IRBAC.ResourceWithPermissions(
            daoVotingResource_,
            permissions_
        );

        return
            [
                daoConfParameterStorageResource_,
                daoRegParameterStorageResource_,
                daoMemberStorageResource_,
                daoVotingRWP_
            ].asArray();
    }
}
