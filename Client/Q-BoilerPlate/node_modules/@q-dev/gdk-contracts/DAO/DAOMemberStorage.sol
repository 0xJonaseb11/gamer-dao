// SPDX-License-Identifier: LGPL-3.0-or-later
pragma solidity 0.8.19;

import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

import "@dlsl/dev-modules/contracts-registry/AbstractDependant.sol";

import "../interfaces/IDAOMemberStorage.sol";

import "./DAORegistry.sol";
import "./PermissionManager.sol";

/**
 * @title DAOMemberStorage
 * @dev The storage contract for the DAO panel members.
 *
 * This contract is part of the DAO, which is responsible for determining the special addresses (experts)
 * which are responsible for some resources (in this context, it is the name of the panel DAO - resource).
 * When a user joins the panel (in the general case, by voting), he will be added to the group
 * associated with the DAO panel (identified by its name).
 */
contract DAOMemberStorage is IDAOMemberStorage, Initializable, AbstractDependant {
    using EnumerableSet for EnumerableSet.AddressSet;

    string public DAO_MEMBER_STORAGE_RESOURCE;

    string public targetPanel;

    PermissionManager public permissionManager;

    EnumerableSet.AddressSet internal _members;

    modifier onlyCreatePermission() {
        _requirePermission(CREATE_PERMISSION);
        _;
    }

    modifier onlyDeletePermission() {
        _requirePermission(DELETE_PERMISSION);
        _;
    }

    function __DAOMemberStorage_init(
        string calldata targetPanel_,
        string calldata resource_
    ) external initializer {
        targetPanel = targetPanel_;

        DAO_MEMBER_STORAGE_RESOURCE = resource_;
    }

    /**
     *  @notice The function that will be called from the MasterDAOFactory to inject dependencies.
     *  @param registryAddress_ the registry to pull dependencies from
     */
    function setDependencies(
        address registryAddress_,
        bytes calldata
    ) external override dependant {
        DAORegistry registry_ = DAORegistry(registryAddress_);

        permissionManager = PermissionManager(registry_.getPermissionManager());
    }

    /**
     * @inheritdoc IDAOResource
     */
    function checkPermission(
        address account_,
        string memory permission_
    ) public view override returns (bool) {
        return permissionManager.hasPermission(account_, DAO_MEMBER_STORAGE_RESOURCE, permission_);
    }

    /**
     * @inheritdoc IDAOResource
     */
    function getResource() external view returns (string memory) {
        return DAO_MEMBER_STORAGE_RESOURCE;
    }

    /**
     * @inheritdoc IDAOMemberStorage
     */
    function addMember(address member_) external override onlyCreatePermission {
        _addMember(member_);
    }

    /**
     * @inheritdoc IDAOMemberStorage
     */
    function addMembers(address[] calldata members_) external override onlyCreatePermission {
        for (uint256 i = 0; i < members_.length; i++) {
            _addMember(members_[i]);
        }
    }

    /**
     * @inheritdoc IDAOMemberStorage
     */
    function removeMember(address member_) external override onlyDeletePermission {
        _removeMember(member_);
    }

    /**
     * @inheritdoc IDAOMemberStorage
     */
    function removeMembers(address[] calldata members_) external override onlyDeletePermission {
        for (uint256 i = 0; i < members_.length; i++) {
            _removeMember(members_[i]);
        }
    }

    /**
     * @inheritdoc IDAOMemberStorage
     */
    function isMember(address member_) external view returns (bool) {
        return _members.contains(member_);
    }

    /**
     * @inheritdoc IDAOMemberStorage
     */
    function getMembers() external view returns (address[] memory) {
        return _members.values();
    }

    /**
     * @inheritdoc IDAOMemberStorage
     */
    function getMembersCount() external view override returns (uint256) {
        return _members.length();
    }

    /**
     * @inheritdoc IDAOMemberStorage
     */
    function getGroup() external view override returns (string[] memory) {
        return getDAOExpertGroup(targetPanel);
    }

    function _addMember(address member_) internal {
        _members.add(member_);

        string[] memory groups_ = getDAOExpertGroup(targetPanel);
        permissionManager.addUserToGroups(member_, groups_);

        emit MemberAdded(member_, groups_[0]);
    }

    function _removeMember(address member_) internal {
        _members.remove(member_);

        string[] memory groups_ = getDAOExpertGroup(targetPanel);
        permissionManager.removeUserFromGroups(member_, groups_);

        emit MemberRemoved(member_, groups_[0]);
    }

    function _requirePermission(string memory permission_) internal view {
        require(
            checkPermission(msg.sender, permission_),
            "[QGDK-004000]-The sender is not allowed to perform the action, access denied."
        );
    }
}
