import type { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, Overrides, PayableOverrides, PopulatedTransaction, Signer, utils } from "ethers";
import type { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from "./common";
export declare namespace IDAOVault {
    type TomeLockInfoStruct = {
        withdrawalAmount: PromiseOrValue<BigNumberish>;
        lockedAmount: PromiseOrValue<BigNumberish>;
        unlockTime: PromiseOrValue<BigNumberish>;
    };
    type TomeLockInfoStructOutput = [BigNumber, BigNumber, BigNumber] & {
        withdrawalAmount: BigNumber;
        lockedAmount: BigNumber;
        unlockTime: BigNumber;
    };
    type ConstitutionDataStruct = {
        isSigned: PromiseOrValue<boolean>;
        signedAt: PromiseOrValue<BigNumberish>;
    };
    type ConstitutionDataStructOutput = [boolean, BigNumber] & {
        isSigned: boolean;
        signedAt: BigNumber;
    };
}
export interface IDAOVaultInterface extends utils.Interface {
    functions: {
        "authorizeBySBT(address)": FunctionFragment;
        "depositERC20(address,uint256)": FunctionFragment;
        "depositNFT(address,uint256)": FunctionFragment;
        "depositNative()": FunctionFragment;
        "getTimeLockInfo(address,address)": FunctionFragment;
        "getTokenSupply(address)": FunctionFragment;
        "getUserConstitutionData(address)": FunctionFragment;
        "getUserNFTs(address,address)": FunctionFragment;
        "getUserTokens(address)": FunctionFragment;
        "getUserVotingPower(address,address)": FunctionFragment;
        "isAuthorizedBySBT(address,address)": FunctionFragment;
        "isSupportedNFT(address)": FunctionFragment;
        "isSupportedSBT(address)": FunctionFragment;
        "lock(address,address,uint256,uint256)": FunctionFragment;
        "revokeSBTAuthorization(address)": FunctionFragment;
        "signConstitution(address,bytes)": FunctionFragment;
        "withdrawERC20(address,uint256)": FunctionFragment;
        "withdrawNFT(address,uint256)": FunctionFragment;
        "withdrawNative(uint256)": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "authorizeBySBT" | "depositERC20" | "depositNFT" | "depositNative" | "getTimeLockInfo" | "getTokenSupply" | "getUserConstitutionData" | "getUserNFTs" | "getUserTokens" | "getUserVotingPower" | "isAuthorizedBySBT" | "isSupportedNFT" | "isSupportedSBT" | "lock" | "revokeSBTAuthorization" | "signConstitution" | "withdrawERC20" | "withdrawNFT" | "withdrawNative"): FunctionFragment;
    encodeFunctionData(functionFragment: "authorizeBySBT", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "depositERC20", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "depositNFT", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "depositNative", values?: undefined): string;
    encodeFunctionData(functionFragment: "getTimeLockInfo", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "getTokenSupply", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "getUserConstitutionData", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "getUserNFTs", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "getUserTokens", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "getUserVotingPower", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "isAuthorizedBySBT", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "isSupportedNFT", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "isSupportedSBT", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "lock", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
    ]): string;
    encodeFunctionData(functionFragment: "revokeSBTAuthorization", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "signConstitution", values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "withdrawERC20", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "withdrawNFT", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "withdrawNative", values: [PromiseOrValue<BigNumberish>]): string;
    decodeFunctionResult(functionFragment: "authorizeBySBT", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "depositERC20", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "depositNFT", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "depositNative", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getTimeLockInfo", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getTokenSupply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getUserConstitutionData", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getUserNFTs", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getUserTokens", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getUserVotingPower", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isAuthorizedBySBT", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isSupportedNFT", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isSupportedSBT", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "lock", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "revokeSBTAuthorization", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "signConstitution", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "withdrawERC20", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "withdrawNFT", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "withdrawNative", data: BytesLike): Result;
    events: {
        "AuthenticatedBySBT(address,address)": EventFragment;
        "AuthorizedBySBT(address,address)": EventFragment;
        "ConstitutionSigned(address)": EventFragment;
        "NFTDeposited(address,address,uint256)": EventFragment;
        "NFTLocked(address,address,uint256,uint256)": EventFragment;
        "NFTWithdrew(address,address,uint256)": EventFragment;
        "SBTAuthorizationRevoked(address,address)": EventFragment;
        "TokensDeposited(address,address,uint256)": EventFragment;
        "TokensLocked(address,address,uint256,uint256)": EventFragment;
        "TokensWithdrew(address,address,uint256)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "AuthenticatedBySBT"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "AuthorizedBySBT"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "ConstitutionSigned"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "NFTDeposited"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "NFTLocked"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "NFTWithdrew"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SBTAuthorizationRevoked"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "TokensDeposited"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "TokensLocked"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "TokensWithdrew"): EventFragment;
}
export interface AuthenticatedBySBTEventObject {
    tokenAddress: string;
    sender: string;
}
export type AuthenticatedBySBTEvent = TypedEvent<[
    string,
    string
], AuthenticatedBySBTEventObject>;
export type AuthenticatedBySBTEventFilter = TypedEventFilter<AuthenticatedBySBTEvent>;
export interface AuthorizedBySBTEventObject {
    tokenAddress: string;
    sender: string;
}
export type AuthorizedBySBTEvent = TypedEvent<[
    string,
    string
], AuthorizedBySBTEventObject>;
export type AuthorizedBySBTEventFilter = TypedEventFilter<AuthorizedBySBTEvent>;
export interface ConstitutionSignedEventObject {
    user: string;
}
export type ConstitutionSignedEvent = TypedEvent<[
    string
], ConstitutionSignedEventObject>;
export type ConstitutionSignedEventFilter = TypedEventFilter<ConstitutionSignedEvent>;
export interface NFTDepositedEventObject {
    tokenAddress: string;
    sender: string;
    tokenId: BigNumber;
}
export type NFTDepositedEvent = TypedEvent<[
    string,
    string,
    BigNumber
], NFTDepositedEventObject>;
export type NFTDepositedEventFilter = TypedEventFilter<NFTDepositedEvent>;
export interface NFTLockedEventObject {
    tokenAddress: string;
    sender: string;
    tokenId: BigNumber;
    unlockTime: BigNumber;
}
export type NFTLockedEvent = TypedEvent<[
    string,
    string,
    BigNumber,
    BigNumber
], NFTLockedEventObject>;
export type NFTLockedEventFilter = TypedEventFilter<NFTLockedEvent>;
export interface NFTWithdrewEventObject {
    tokenAddress: string;
    sender: string;
    tokenId: BigNumber;
}
export type NFTWithdrewEvent = TypedEvent<[
    string,
    string,
    BigNumber
], NFTWithdrewEventObject>;
export type NFTWithdrewEventFilter = TypedEventFilter<NFTWithdrewEvent>;
export interface SBTAuthorizationRevokedEventObject {
    tokenAddress: string;
    sender: string;
}
export type SBTAuthorizationRevokedEvent = TypedEvent<[
    string,
    string
], SBTAuthorizationRevokedEventObject>;
export type SBTAuthorizationRevokedEventFilter = TypedEventFilter<SBTAuthorizationRevokedEvent>;
export interface TokensDepositedEventObject {
    tokenAddress: string;
    sender: string;
    amount: BigNumber;
}
export type TokensDepositedEvent = TypedEvent<[
    string,
    string,
    BigNumber
], TokensDepositedEventObject>;
export type TokensDepositedEventFilter = TypedEventFilter<TokensDepositedEvent>;
export interface TokensLockedEventObject {
    tokenAddress: string;
    sender: string;
    amount: BigNumber;
    unlockTime: BigNumber;
}
export type TokensLockedEvent = TypedEvent<[
    string,
    string,
    BigNumber,
    BigNumber
], TokensLockedEventObject>;
export type TokensLockedEventFilter = TypedEventFilter<TokensLockedEvent>;
export interface TokensWithdrewEventObject {
    tokenAddress: string;
    sender: string;
    amount: BigNumber;
}
export type TokensWithdrewEvent = TypedEvent<[
    string,
    string,
    BigNumber
], TokensWithdrewEventObject>;
export type TokensWithdrewEventFilter = TypedEventFilter<TokensWithdrewEvent>;
export interface IDAOVault extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: IDAOVaultInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        authorizeBySBT(tokenAddress_: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        depositERC20(tokenAddress_: PromiseOrValue<string>, amount_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        depositNFT(tokenAddress_: PromiseOrValue<string>, tokenId_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        depositNative(overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        getTimeLockInfo(userAddress_: PromiseOrValue<string>, tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[
            IDAOVault.TomeLockInfoStructOutput
        ] & {
            info_: IDAOVault.TomeLockInfoStructOutput;
        }>;
        getTokenSupply(tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;
        getUserConstitutionData(userAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[IDAOVault.ConstitutionDataStructOutput]>;
        getUserNFTs(userAddress_: PromiseOrValue<string>, tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber[]]>;
        getUserTokens(userAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string[]]>;
        getUserVotingPower(userAddress_: PromiseOrValue<string>, tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;
        isAuthorizedBySBT(sender_: PromiseOrValue<string>, tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
        isSupportedNFT(tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
        isSupportedSBT(tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
        lock(sender_: PromiseOrValue<string>, tokenAddress_: PromiseOrValue<string>, amount_: PromiseOrValue<BigNumberish>, timeToLock_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        revokeSBTAuthorization(tokenAddress_: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        signConstitution(signer_: PromiseOrValue<string>, signature_: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        withdrawERC20(tokenAddress_: PromiseOrValue<string>, amount_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        withdrawNFT(tokenAddress_: PromiseOrValue<string>, tokenId_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        withdrawNative(amount_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
    };
    authorizeBySBT(tokenAddress_: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    depositERC20(tokenAddress_: PromiseOrValue<string>, amount_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    depositNFT(tokenAddress_: PromiseOrValue<string>, tokenId_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    depositNative(overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    getTimeLockInfo(userAddress_: PromiseOrValue<string>, tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<IDAOVault.TomeLockInfoStructOutput>;
    getTokenSupply(tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
    getUserConstitutionData(userAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<IDAOVault.ConstitutionDataStructOutput>;
    getUserNFTs(userAddress_: PromiseOrValue<string>, tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber[]>;
    getUserTokens(userAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string[]>;
    getUserVotingPower(userAddress_: PromiseOrValue<string>, tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
    isAuthorizedBySBT(sender_: PromiseOrValue<string>, tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
    isSupportedNFT(tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
    isSupportedSBT(tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
    lock(sender_: PromiseOrValue<string>, tokenAddress_: PromiseOrValue<string>, amount_: PromiseOrValue<BigNumberish>, timeToLock_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    revokeSBTAuthorization(tokenAddress_: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    signConstitution(signer_: PromiseOrValue<string>, signature_: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    withdrawERC20(tokenAddress_: PromiseOrValue<string>, amount_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    withdrawNFT(tokenAddress_: PromiseOrValue<string>, tokenId_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    withdrawNative(amount_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        authorizeBySBT(tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        depositERC20(tokenAddress_: PromiseOrValue<string>, amount_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        depositNFT(tokenAddress_: PromiseOrValue<string>, tokenId_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        depositNative(overrides?: CallOverrides): Promise<void>;
        getTimeLockInfo(userAddress_: PromiseOrValue<string>, tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<IDAOVault.TomeLockInfoStructOutput>;
        getTokenSupply(tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        getUserConstitutionData(userAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<IDAOVault.ConstitutionDataStructOutput>;
        getUserNFTs(userAddress_: PromiseOrValue<string>, tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber[]>;
        getUserTokens(userAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string[]>;
        getUserVotingPower(userAddress_: PromiseOrValue<string>, tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        isAuthorizedBySBT(sender_: PromiseOrValue<string>, tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
        isSupportedNFT(tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
        isSupportedSBT(tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
        lock(sender_: PromiseOrValue<string>, tokenAddress_: PromiseOrValue<string>, amount_: PromiseOrValue<BigNumberish>, timeToLock_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        revokeSBTAuthorization(tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        signConstitution(signer_: PromiseOrValue<string>, signature_: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        withdrawERC20(tokenAddress_: PromiseOrValue<string>, amount_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        withdrawNFT(tokenAddress_: PromiseOrValue<string>, tokenId_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        withdrawNative(amount_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
    };
    filters: {
        "AuthenticatedBySBT(address,address)"(tokenAddress?: PromiseOrValue<string> | null, sender?: PromiseOrValue<string> | null): AuthenticatedBySBTEventFilter;
        AuthenticatedBySBT(tokenAddress?: PromiseOrValue<string> | null, sender?: PromiseOrValue<string> | null): AuthenticatedBySBTEventFilter;
        "AuthorizedBySBT(address,address)"(tokenAddress?: PromiseOrValue<string> | null, sender?: PromiseOrValue<string> | null): AuthorizedBySBTEventFilter;
        AuthorizedBySBT(tokenAddress?: PromiseOrValue<string> | null, sender?: PromiseOrValue<string> | null): AuthorizedBySBTEventFilter;
        "ConstitutionSigned(address)"(user?: PromiseOrValue<string> | null): ConstitutionSignedEventFilter;
        ConstitutionSigned(user?: PromiseOrValue<string> | null): ConstitutionSignedEventFilter;
        "NFTDeposited(address,address,uint256)"(tokenAddress?: PromiseOrValue<string> | null, sender?: PromiseOrValue<string> | null, tokenId?: null): NFTDepositedEventFilter;
        NFTDeposited(tokenAddress?: PromiseOrValue<string> | null, sender?: PromiseOrValue<string> | null, tokenId?: null): NFTDepositedEventFilter;
        "NFTLocked(address,address,uint256,uint256)"(tokenAddress?: PromiseOrValue<string> | null, sender?: PromiseOrValue<string> | null, tokenId?: null, unlockTime?: null): NFTLockedEventFilter;
        NFTLocked(tokenAddress?: PromiseOrValue<string> | null, sender?: PromiseOrValue<string> | null, tokenId?: null, unlockTime?: null): NFTLockedEventFilter;
        "NFTWithdrew(address,address,uint256)"(tokenAddress?: PromiseOrValue<string> | null, sender?: PromiseOrValue<string> | null, tokenId?: null): NFTWithdrewEventFilter;
        NFTWithdrew(tokenAddress?: PromiseOrValue<string> | null, sender?: PromiseOrValue<string> | null, tokenId?: null): NFTWithdrewEventFilter;
        "SBTAuthorizationRevoked(address,address)"(tokenAddress?: PromiseOrValue<string> | null, sender?: PromiseOrValue<string> | null): SBTAuthorizationRevokedEventFilter;
        SBTAuthorizationRevoked(tokenAddress?: PromiseOrValue<string> | null, sender?: PromiseOrValue<string> | null): SBTAuthorizationRevokedEventFilter;
        "TokensDeposited(address,address,uint256)"(tokenAddress?: PromiseOrValue<string> | null, sender?: PromiseOrValue<string> | null, amount?: null): TokensDepositedEventFilter;
        TokensDeposited(tokenAddress?: PromiseOrValue<string> | null, sender?: PromiseOrValue<string> | null, amount?: null): TokensDepositedEventFilter;
        "TokensLocked(address,address,uint256,uint256)"(tokenAddress?: PromiseOrValue<string> | null, sender?: PromiseOrValue<string> | null, amount?: null, unlockTime?: null): TokensLockedEventFilter;
        TokensLocked(tokenAddress?: PromiseOrValue<string> | null, sender?: PromiseOrValue<string> | null, amount?: null, unlockTime?: null): TokensLockedEventFilter;
        "TokensWithdrew(address,address,uint256)"(tokenAddress?: PromiseOrValue<string> | null, sender?: PromiseOrValue<string> | null, amount?: null): TokensWithdrewEventFilter;
        TokensWithdrew(tokenAddress?: PromiseOrValue<string> | null, sender?: PromiseOrValue<string> | null, amount?: null): TokensWithdrewEventFilter;
    };
    estimateGas: {
        authorizeBySBT(tokenAddress_: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        depositERC20(tokenAddress_: PromiseOrValue<string>, amount_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        depositNFT(tokenAddress_: PromiseOrValue<string>, tokenId_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        depositNative(overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        getTimeLockInfo(userAddress_: PromiseOrValue<string>, tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        getTokenSupply(tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        getUserConstitutionData(userAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        getUserNFTs(userAddress_: PromiseOrValue<string>, tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        getUserTokens(userAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        getUserVotingPower(userAddress_: PromiseOrValue<string>, tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        isAuthorizedBySBT(sender_: PromiseOrValue<string>, tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        isSupportedNFT(tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        isSupportedSBT(tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        lock(sender_: PromiseOrValue<string>, tokenAddress_: PromiseOrValue<string>, amount_: PromiseOrValue<BigNumberish>, timeToLock_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        revokeSBTAuthorization(tokenAddress_: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        signConstitution(signer_: PromiseOrValue<string>, signature_: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        withdrawERC20(tokenAddress_: PromiseOrValue<string>, amount_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        withdrawNFT(tokenAddress_: PromiseOrValue<string>, tokenId_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        withdrawNative(amount_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        authorizeBySBT(tokenAddress_: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        depositERC20(tokenAddress_: PromiseOrValue<string>, amount_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        depositNFT(tokenAddress_: PromiseOrValue<string>, tokenId_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        depositNative(overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        getTimeLockInfo(userAddress_: PromiseOrValue<string>, tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getTokenSupply(tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getUserConstitutionData(userAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getUserNFTs(userAddress_: PromiseOrValue<string>, tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getUserTokens(userAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getUserVotingPower(userAddress_: PromiseOrValue<string>, tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isAuthorizedBySBT(sender_: PromiseOrValue<string>, tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isSupportedNFT(tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isSupportedSBT(tokenAddress_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        lock(sender_: PromiseOrValue<string>, tokenAddress_: PromiseOrValue<string>, amount_: PromiseOrValue<BigNumberish>, timeToLock_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        revokeSBTAuthorization(tokenAddress_: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        signConstitution(signer_: PromiseOrValue<string>, signature_: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        withdrawERC20(tokenAddress_: PromiseOrValue<string>, amount_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        withdrawNFT(tokenAddress_: PromiseOrValue<string>, tokenId_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        withdrawNative(amount_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
    };
}
