import type { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, Overrides, PopulatedTransaction, Signer, utils } from "ethers";
import type { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from "./common";
export declare namespace IDAOVoting {
    type VotingParamsStruct = {
        votingType: PromiseOrValue<BigNumberish>;
        votingStartTime: PromiseOrValue<BigNumberish>;
        votingEndTime: PromiseOrValue<BigNumberish>;
        vetoEndTime: PromiseOrValue<BigNumberish>;
        proposalExecutionPeriod: PromiseOrValue<BigNumberish>;
        requiredQuorum: PromiseOrValue<BigNumberish>;
        requiredMajority: PromiseOrValue<BigNumberish>;
        requiredVetoQuorum: PromiseOrValue<BigNumberish>;
    };
    type VotingParamsStructOutput = [
        number,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
    ] & {
        votingType: number;
        votingStartTime: BigNumber;
        votingEndTime: BigNumber;
        vetoEndTime: BigNumber;
        proposalExecutionPeriod: BigNumber;
        requiredQuorum: BigNumber;
        requiredMajority: BigNumber;
        requiredVetoQuorum: BigNumber;
    };
    type VotingCountersStruct = {
        votedFor: PromiseOrValue<BigNumberish>;
        votedAgainst: PromiseOrValue<BigNumberish>;
        vetoesCount: PromiseOrValue<BigNumberish>;
    };
    type VotingCountersStructOutput = [BigNumber, BigNumber, BigNumber] & {
        votedFor: BigNumber;
        votedAgainst: BigNumber;
        vetoesCount: BigNumber;
    };
    type DAOProposalStruct = {
        id: PromiseOrValue<BigNumberish>;
        remark: PromiseOrValue<string>;
        relatedExpertPanel: PromiseOrValue<string>;
        relatedVotingSituation: PromiseOrValue<string>;
        callData: PromiseOrValue<BytesLike>;
        target: PromiseOrValue<string>;
        params: IDAOVoting.VotingParamsStruct;
        counters: IDAOVoting.VotingCountersStruct;
        executed: PromiseOrValue<boolean>;
    };
    type DAOProposalStructOutput = [
        BigNumber,
        string,
        string,
        string,
        string,
        string,
        IDAOVoting.VotingParamsStructOutput,
        IDAOVoting.VotingCountersStructOutput,
        boolean
    ] & {
        id: BigNumber;
        remark: string;
        relatedExpertPanel: string;
        relatedVotingSituation: string;
        callData: string;
        target: string;
        params: IDAOVoting.VotingParamsStructOutput;
        counters: IDAOVoting.VotingCountersStructOutput;
        executed: boolean;
    };
    type DAOVotingValuesStruct = {
        votingPeriod: PromiseOrValue<BigNumberish>;
        vetoPeriod: PromiseOrValue<BigNumberish>;
        proposalExecutionPeriod: PromiseOrValue<BigNumberish>;
        requiredQuorum: PromiseOrValue<BigNumberish>;
        requiredMajority: PromiseOrValue<BigNumberish>;
        requiredVetoQuorum: PromiseOrValue<BigNumberish>;
        votingType: PromiseOrValue<BigNumberish>;
        votingTarget: PromiseOrValue<string>;
        votingMinAmount: PromiseOrValue<BigNumberish>;
    };
    type DAOVotingValuesStructOutput = [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        string,
        BigNumber
    ] & {
        votingPeriod: BigNumber;
        vetoPeriod: BigNumber;
        proposalExecutionPeriod: BigNumber;
        requiredQuorum: BigNumber;
        requiredMajority: BigNumber;
        requiredVetoQuorum: BigNumber;
        votingType: BigNumber;
        votingTarget: string;
        votingMinAmount: BigNumber;
    };
    type ConstructorParamsStruct = {
        panelName: PromiseOrValue<string>;
        votingToken: PromiseOrValue<string>;
    };
    type ConstructorParamsStructOutput = [string, string] & {
        panelName: string;
        votingToken: string;
    };
    type InitialSituationStruct = {
        votingSituationName: PromiseOrValue<string>;
        votingValues: IDAOVoting.DAOVotingValuesStruct;
    };
    type InitialSituationStructOutput = [
        string,
        IDAOVoting.DAOVotingValuesStructOutput
    ] & {
        votingSituationName: string;
        votingValues: IDAOVoting.DAOVotingValuesStructOutput;
    };
    type VotingStatsStruct = {
        requiredQuorum: PromiseOrValue<BigNumberish>;
        currentQuorum: PromiseOrValue<BigNumberish>;
        requiredMajority: PromiseOrValue<BigNumberish>;
        currentMajority: PromiseOrValue<BigNumberish>;
        currentVetoQuorum: PromiseOrValue<BigNumberish>;
        requiredVetoQuorum: PromiseOrValue<BigNumberish>;
    };
    type VotingStatsStructOutput = [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
    ] & {
        requiredQuorum: BigNumber;
        currentQuorum: BigNumber;
        requiredMajority: BigNumber;
        currentMajority: BigNumber;
        currentVetoQuorum: BigNumber;
        requiredVetoQuorum: BigNumber;
    };
}
export interface ExpertsDAOVotingInterface extends utils.Interface {
    functions: {
        "DAO_VOTING_RESOURCE()": FunctionFragment;
        "PROPOSAL_EXECUTION_PERIOD()": FunctionFragment;
        "REQUIRED_MAJORITY()": FunctionFragment;
        "REQUIRED_QUORUM()": FunctionFragment;
        "REQUIRED_VETO_QUORUM()": FunctionFragment;
        "VETO_PERIOD()": FunctionFragment;
        "VOTING_MIN_AMOUNT()": FunctionFragment;
        "VOTING_PERIOD()": FunctionFragment;
        "VOTING_TARGET()": FunctionFragment;
        "VOTING_TYPE()": FunctionFragment;
        "__DAOVoting_init((string,address),string)": FunctionFragment;
        "checkPermission(address,string)": FunctionFragment;
        "createDAOVotingSituation((string,(uint256,uint256,uint256,uint256,uint256,uint256,uint256,string,uint256)))": FunctionFragment;
        "createProposal(string,string,bytes)": FunctionFragment;
        "daoMemberStorage()": FunctionFragment;
        "daoParameterStorage()": FunctionFragment;
        "daoRegistry()": FunctionFragment;
        "daoVault()": FunctionFragment;
        "executeProposal(uint256)": FunctionFragment;
        "getInjector()": FunctionFragment;
        "getProposal(uint256)": FunctionFragment;
        "getProposalList(uint256,uint256)": FunctionFragment;
        "getProposalStatus(uint256)": FunctionFragment;
        "getProposalVotingStats(uint256)": FunctionFragment;
        "getResource()": FunctionFragment;
        "getVotingSituationInfo(string)": FunctionFragment;
        "getVotingSituations()": FunctionFragment;
        "hasUserVetoed(uint256,address)": FunctionFragment;
        "hasUserVoted(uint256,address)": FunctionFragment;
        "permissionManager()": FunctionFragment;
        "proposalCount()": FunctionFragment;
        "proposals(uint256)": FunctionFragment;
        "removeVotingSituation(string)": FunctionFragment;
        "setDependencies(address,bytes)": FunctionFragment;
        "setInjector(address)": FunctionFragment;
        "targetPanel()": FunctionFragment;
        "veto(uint256)": FunctionFragment;
        "voteAgainst(uint256)": FunctionFragment;
        "voteFor(uint256)": FunctionFragment;
        "votingToken()": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "DAO_VOTING_RESOURCE" | "PROPOSAL_EXECUTION_PERIOD" | "REQUIRED_MAJORITY" | "REQUIRED_QUORUM" | "REQUIRED_VETO_QUORUM" | "VETO_PERIOD" | "VOTING_MIN_AMOUNT" | "VOTING_PERIOD" | "VOTING_TARGET" | "VOTING_TYPE" | "__DAOVoting_init" | "checkPermission" | "createDAOVotingSituation" | "createProposal" | "daoMemberStorage" | "daoParameterStorage" | "daoRegistry" | "daoVault" | "executeProposal" | "getInjector" | "getProposal" | "getProposalList" | "getProposalStatus" | "getProposalVotingStats" | "getResource" | "getVotingSituationInfo" | "getVotingSituations" | "hasUserVetoed" | "hasUserVoted" | "permissionManager" | "proposalCount" | "proposals" | "removeVotingSituation" | "setDependencies" | "setInjector" | "targetPanel" | "veto" | "voteAgainst" | "voteFor" | "votingToken"): FunctionFragment;
    encodeFunctionData(functionFragment: "DAO_VOTING_RESOURCE", values?: undefined): string;
    encodeFunctionData(functionFragment: "PROPOSAL_EXECUTION_PERIOD", values?: undefined): string;
    encodeFunctionData(functionFragment: "REQUIRED_MAJORITY", values?: undefined): string;
    encodeFunctionData(functionFragment: "REQUIRED_QUORUM", values?: undefined): string;
    encodeFunctionData(functionFragment: "REQUIRED_VETO_QUORUM", values?: undefined): string;
    encodeFunctionData(functionFragment: "VETO_PERIOD", values?: undefined): string;
    encodeFunctionData(functionFragment: "VOTING_MIN_AMOUNT", values?: undefined): string;
    encodeFunctionData(functionFragment: "VOTING_PERIOD", values?: undefined): string;
    encodeFunctionData(functionFragment: "VOTING_TARGET", values?: undefined): string;
    encodeFunctionData(functionFragment: "VOTING_TYPE", values?: undefined): string;
    encodeFunctionData(functionFragment: "__DAOVoting_init", values: [IDAOVoting.ConstructorParamsStruct, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "checkPermission", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "createDAOVotingSituation", values: [IDAOVoting.InitialSituationStruct]): string;
    encodeFunctionData(functionFragment: "createProposal", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "daoMemberStorage", values?: undefined): string;
    encodeFunctionData(functionFragment: "daoParameterStorage", values?: undefined): string;
    encodeFunctionData(functionFragment: "daoRegistry", values?: undefined): string;
    encodeFunctionData(functionFragment: "daoVault", values?: undefined): string;
    encodeFunctionData(functionFragment: "executeProposal", values: [PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "getInjector", values?: undefined): string;
    encodeFunctionData(functionFragment: "getProposal", values: [PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "getProposalList", values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "getProposalStatus", values: [PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "getProposalVotingStats", values: [PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "getResource", values?: undefined): string;
    encodeFunctionData(functionFragment: "getVotingSituationInfo", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "getVotingSituations", values?: undefined): string;
    encodeFunctionData(functionFragment: "hasUserVetoed", values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "hasUserVoted", values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "permissionManager", values?: undefined): string;
    encodeFunctionData(functionFragment: "proposalCount", values?: undefined): string;
    encodeFunctionData(functionFragment: "proposals", values: [PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "removeVotingSituation", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "setDependencies", values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "setInjector", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "targetPanel", values?: undefined): string;
    encodeFunctionData(functionFragment: "veto", values: [PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "voteAgainst", values: [PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "voteFor", values: [PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "votingToken", values?: undefined): string;
    decodeFunctionResult(functionFragment: "DAO_VOTING_RESOURCE", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "PROPOSAL_EXECUTION_PERIOD", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "REQUIRED_MAJORITY", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "REQUIRED_QUORUM", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "REQUIRED_VETO_QUORUM", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "VETO_PERIOD", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "VOTING_MIN_AMOUNT", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "VOTING_PERIOD", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "VOTING_TARGET", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "VOTING_TYPE", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "__DAOVoting_init", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "checkPermission", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "createDAOVotingSituation", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "createProposal", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "daoMemberStorage", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "daoParameterStorage", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "daoRegistry", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "daoVault", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "executeProposal", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getInjector", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getProposal", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getProposalList", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getProposalStatus", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getProposalVotingStats", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getResource", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVotingSituationInfo", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getVotingSituations", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "hasUserVetoed", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "hasUserVoted", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "permissionManager", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "proposalCount", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "proposals", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "removeVotingSituation", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setDependencies", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setInjector", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "targetPanel", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "veto", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "voteAgainst", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "voteFor", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "votingToken", data: BytesLike): Result;
    events: {
        "Initialized(uint8)": EventFragment;
        "ProposalCreated(uint256,tuple)": EventFragment;
        "ProposalExecuted(uint256)": EventFragment;
        "UserVetoed(uint256,address)": EventFragment;
        "UserVoted(uint256,address,uint256,uint8)": EventFragment;
        "VotingSituationCreated(string,tuple)": EventFragment;
        "VotingSituationRemoved(string)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "ProposalCreated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "ProposalExecuted"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "UserVetoed"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "UserVoted"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "VotingSituationCreated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "VotingSituationRemoved"): EventFragment;
}
export interface InitializedEventObject {
    version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;
export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;
export interface ProposalCreatedEventObject {
    id: BigNumber;
    proposal: IDAOVoting.DAOProposalStructOutput;
}
export type ProposalCreatedEvent = TypedEvent<[
    BigNumber,
    IDAOVoting.DAOProposalStructOutput
], ProposalCreatedEventObject>;
export type ProposalCreatedEventFilter = TypedEventFilter<ProposalCreatedEvent>;
export interface ProposalExecutedEventObject {
    id: BigNumber;
}
export type ProposalExecutedEvent = TypedEvent<[
    BigNumber
], ProposalExecutedEventObject>;
export type ProposalExecutedEventFilter = TypedEventFilter<ProposalExecutedEvent>;
export interface UserVetoedEventObject {
    id: BigNumber;
    voter: string;
}
export type UserVetoedEvent = TypedEvent<[
    BigNumber,
    string
], UserVetoedEventObject>;
export type UserVetoedEventFilter = TypedEventFilter<UserVetoedEvent>;
export interface UserVotedEventObject {
    id: BigNumber;
    voter: string;
    votingPower: BigNumber;
    option: number;
}
export type UserVotedEvent = TypedEvent<[
    BigNumber,
    string,
    BigNumber,
    number
], UserVotedEventObject>;
export type UserVotedEventFilter = TypedEventFilter<UserVotedEvent>;
export interface VotingSituationCreatedEventObject {
    name: string;
    values: IDAOVoting.DAOVotingValuesStructOutput;
}
export type VotingSituationCreatedEvent = TypedEvent<[
    string,
    IDAOVoting.DAOVotingValuesStructOutput
], VotingSituationCreatedEventObject>;
export type VotingSituationCreatedEventFilter = TypedEventFilter<VotingSituationCreatedEvent>;
export interface VotingSituationRemovedEventObject {
    name: string;
}
export type VotingSituationRemovedEvent = TypedEvent<[
    string
], VotingSituationRemovedEventObject>;
export type VotingSituationRemovedEventFilter = TypedEventFilter<VotingSituationRemovedEvent>;
export interface ExpertsDAOVoting extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: ExpertsDAOVotingInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        DAO_VOTING_RESOURCE(overrides?: CallOverrides): Promise<[string]>;
        PROPOSAL_EXECUTION_PERIOD(overrides?: CallOverrides): Promise<[string]>;
        REQUIRED_MAJORITY(overrides?: CallOverrides): Promise<[string]>;
        REQUIRED_QUORUM(overrides?: CallOverrides): Promise<[string]>;
        REQUIRED_VETO_QUORUM(overrides?: CallOverrides): Promise<[string]>;
        VETO_PERIOD(overrides?: CallOverrides): Promise<[string]>;
        VOTING_MIN_AMOUNT(overrides?: CallOverrides): Promise<[string]>;
        VOTING_PERIOD(overrides?: CallOverrides): Promise<[string]>;
        VOTING_TARGET(overrides?: CallOverrides): Promise<[string]>;
        VOTING_TYPE(overrides?: CallOverrides): Promise<[string]>;
        __DAOVoting_init(params_: IDAOVoting.ConstructorParamsStruct, resource_: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        checkPermission(member_: PromiseOrValue<string>, permission_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
        createDAOVotingSituation(conf_: IDAOVoting.InitialSituationStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        createProposal(situation_: PromiseOrValue<string>, remark_: PromiseOrValue<string>, callData_: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        daoMemberStorage(overrides?: CallOverrides): Promise<[string]>;
        daoParameterStorage(overrides?: CallOverrides): Promise<[string]>;
        daoRegistry(overrides?: CallOverrides): Promise<[string]>;
        daoVault(overrides?: CallOverrides): Promise<[string]>;
        executeProposal(proposalId_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        getInjector(overrides?: CallOverrides): Promise<[string] & {
            injector_: string;
        }>;
        getProposal(proposalId_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[IDAOVoting.DAOProposalStructOutput]>;
        getProposalList(offset_: PromiseOrValue<BigNumberish>, limit_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[IDAOVoting.DAOProposalStructOutput[]]>;
        getProposalStatus(proposalId_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[number]>;
        getProposalVotingStats(proposalId_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[IDAOVoting.VotingStatsStructOutput]>;
        getResource(overrides?: CallOverrides): Promise<[string]>;
        getVotingSituationInfo(situation_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[IDAOVoting.DAOVotingValuesStructOutput]>;
        getVotingSituations(overrides?: CallOverrides): Promise<[string[]]>;
        hasUserVetoed(arg0: PromiseOrValue<BigNumberish>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
        hasUserVoted(arg0: PromiseOrValue<BigNumberish>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
        permissionManager(overrides?: CallOverrides): Promise<[string]>;
        proposalCount(overrides?: CallOverrides): Promise<[BigNumber]>;
        proposals(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[
            BigNumber,
            string,
            string,
            string,
            string,
            string,
            IDAOVoting.VotingParamsStructOutput,
            IDAOVoting.VotingCountersStructOutput,
            boolean
        ] & {
            id: BigNumber;
            remark: string;
            relatedExpertPanel: string;
            relatedVotingSituation: string;
            callData: string;
            target: string;
            params: IDAOVoting.VotingParamsStructOutput;
            counters: IDAOVoting.VotingCountersStructOutput;
            executed: boolean;
        }>;
        removeVotingSituation(situation_: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setDependencies(registryAddress_: PromiseOrValue<string>, data_: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setInjector(injector_: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        targetPanel(overrides?: CallOverrides): Promise<[string]>;
        veto(proposalId_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        voteAgainst(proposalId_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        voteFor(proposalId_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        votingToken(overrides?: CallOverrides): Promise<[string]>;
    };
    DAO_VOTING_RESOURCE(overrides?: CallOverrides): Promise<string>;
    PROPOSAL_EXECUTION_PERIOD(overrides?: CallOverrides): Promise<string>;
    REQUIRED_MAJORITY(overrides?: CallOverrides): Promise<string>;
    REQUIRED_QUORUM(overrides?: CallOverrides): Promise<string>;
    REQUIRED_VETO_QUORUM(overrides?: CallOverrides): Promise<string>;
    VETO_PERIOD(overrides?: CallOverrides): Promise<string>;
    VOTING_MIN_AMOUNT(overrides?: CallOverrides): Promise<string>;
    VOTING_PERIOD(overrides?: CallOverrides): Promise<string>;
    VOTING_TARGET(overrides?: CallOverrides): Promise<string>;
    VOTING_TYPE(overrides?: CallOverrides): Promise<string>;
    __DAOVoting_init(params_: IDAOVoting.ConstructorParamsStruct, resource_: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    checkPermission(member_: PromiseOrValue<string>, permission_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
    createDAOVotingSituation(conf_: IDAOVoting.InitialSituationStruct, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    createProposal(situation_: PromiseOrValue<string>, remark_: PromiseOrValue<string>, callData_: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    daoMemberStorage(overrides?: CallOverrides): Promise<string>;
    daoParameterStorage(overrides?: CallOverrides): Promise<string>;
    daoRegistry(overrides?: CallOverrides): Promise<string>;
    daoVault(overrides?: CallOverrides): Promise<string>;
    executeProposal(proposalId_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    getInjector(overrides?: CallOverrides): Promise<string>;
    getProposal(proposalId_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<IDAOVoting.DAOProposalStructOutput>;
    getProposalList(offset_: PromiseOrValue<BigNumberish>, limit_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<IDAOVoting.DAOProposalStructOutput[]>;
    getProposalStatus(proposalId_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<number>;
    getProposalVotingStats(proposalId_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<IDAOVoting.VotingStatsStructOutput>;
    getResource(overrides?: CallOverrides): Promise<string>;
    getVotingSituationInfo(situation_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<IDAOVoting.DAOVotingValuesStructOutput>;
    getVotingSituations(overrides?: CallOverrides): Promise<string[]>;
    hasUserVetoed(arg0: PromiseOrValue<BigNumberish>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
    hasUserVoted(arg0: PromiseOrValue<BigNumberish>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
    permissionManager(overrides?: CallOverrides): Promise<string>;
    proposalCount(overrides?: CallOverrides): Promise<BigNumber>;
    proposals(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[
        BigNumber,
        string,
        string,
        string,
        string,
        string,
        IDAOVoting.VotingParamsStructOutput,
        IDAOVoting.VotingCountersStructOutput,
        boolean
    ] & {
        id: BigNumber;
        remark: string;
        relatedExpertPanel: string;
        relatedVotingSituation: string;
        callData: string;
        target: string;
        params: IDAOVoting.VotingParamsStructOutput;
        counters: IDAOVoting.VotingCountersStructOutput;
        executed: boolean;
    }>;
    removeVotingSituation(situation_: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setDependencies(registryAddress_: PromiseOrValue<string>, data_: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setInjector(injector_: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    targetPanel(overrides?: CallOverrides): Promise<string>;
    veto(proposalId_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    voteAgainst(proposalId_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    voteFor(proposalId_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    votingToken(overrides?: CallOverrides): Promise<string>;
    callStatic: {
        DAO_VOTING_RESOURCE(overrides?: CallOverrides): Promise<string>;
        PROPOSAL_EXECUTION_PERIOD(overrides?: CallOverrides): Promise<string>;
        REQUIRED_MAJORITY(overrides?: CallOverrides): Promise<string>;
        REQUIRED_QUORUM(overrides?: CallOverrides): Promise<string>;
        REQUIRED_VETO_QUORUM(overrides?: CallOverrides): Promise<string>;
        VETO_PERIOD(overrides?: CallOverrides): Promise<string>;
        VOTING_MIN_AMOUNT(overrides?: CallOverrides): Promise<string>;
        VOTING_PERIOD(overrides?: CallOverrides): Promise<string>;
        VOTING_TARGET(overrides?: CallOverrides): Promise<string>;
        VOTING_TYPE(overrides?: CallOverrides): Promise<string>;
        __DAOVoting_init(params_: IDAOVoting.ConstructorParamsStruct, resource_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        checkPermission(member_: PromiseOrValue<string>, permission_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
        createDAOVotingSituation(conf_: IDAOVoting.InitialSituationStruct, overrides?: CallOverrides): Promise<void>;
        createProposal(situation_: PromiseOrValue<string>, remark_: PromiseOrValue<string>, callData_: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
        daoMemberStorage(overrides?: CallOverrides): Promise<string>;
        daoParameterStorage(overrides?: CallOverrides): Promise<string>;
        daoRegistry(overrides?: CallOverrides): Promise<string>;
        daoVault(overrides?: CallOverrides): Promise<string>;
        executeProposal(proposalId_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        getInjector(overrides?: CallOverrides): Promise<string>;
        getProposal(proposalId_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<IDAOVoting.DAOProposalStructOutput>;
        getProposalList(offset_: PromiseOrValue<BigNumberish>, limit_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<IDAOVoting.DAOProposalStructOutput[]>;
        getProposalStatus(proposalId_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<number>;
        getProposalVotingStats(proposalId_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<IDAOVoting.VotingStatsStructOutput>;
        getResource(overrides?: CallOverrides): Promise<string>;
        getVotingSituationInfo(situation_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<IDAOVoting.DAOVotingValuesStructOutput>;
        getVotingSituations(overrides?: CallOverrides): Promise<string[]>;
        hasUserVetoed(arg0: PromiseOrValue<BigNumberish>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
        hasUserVoted(arg0: PromiseOrValue<BigNumberish>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
        permissionManager(overrides?: CallOverrides): Promise<string>;
        proposalCount(overrides?: CallOverrides): Promise<BigNumber>;
        proposals(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[
            BigNumber,
            string,
            string,
            string,
            string,
            string,
            IDAOVoting.VotingParamsStructOutput,
            IDAOVoting.VotingCountersStructOutput,
            boolean
        ] & {
            id: BigNumber;
            remark: string;
            relatedExpertPanel: string;
            relatedVotingSituation: string;
            callData: string;
            target: string;
            params: IDAOVoting.VotingParamsStructOutput;
            counters: IDAOVoting.VotingCountersStructOutput;
            executed: boolean;
        }>;
        removeVotingSituation(situation_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        setDependencies(registryAddress_: PromiseOrValue<string>, data_: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        setInjector(injector_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        targetPanel(overrides?: CallOverrides): Promise<string>;
        veto(proposalId_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        voteAgainst(proposalId_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        voteFor(proposalId_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        votingToken(overrides?: CallOverrides): Promise<string>;
    };
    filters: {
        "Initialized(uint8)"(version?: null): InitializedEventFilter;
        Initialized(version?: null): InitializedEventFilter;
        "ProposalCreated(uint256,tuple)"(id?: PromiseOrValue<BigNumberish> | null, proposal?: null): ProposalCreatedEventFilter;
        ProposalCreated(id?: PromiseOrValue<BigNumberish> | null, proposal?: null): ProposalCreatedEventFilter;
        "ProposalExecuted(uint256)"(id?: PromiseOrValue<BigNumberish> | null): ProposalExecutedEventFilter;
        ProposalExecuted(id?: PromiseOrValue<BigNumberish> | null): ProposalExecutedEventFilter;
        "UserVetoed(uint256,address)"(id?: PromiseOrValue<BigNumberish> | null, voter?: PromiseOrValue<string> | null): UserVetoedEventFilter;
        UserVetoed(id?: PromiseOrValue<BigNumberish> | null, voter?: PromiseOrValue<string> | null): UserVetoedEventFilter;
        "UserVoted(uint256,address,uint256,uint8)"(id?: PromiseOrValue<BigNumberish> | null, voter?: PromiseOrValue<string> | null, votingPower?: null, option?: null): UserVotedEventFilter;
        UserVoted(id?: PromiseOrValue<BigNumberish> | null, voter?: PromiseOrValue<string> | null, votingPower?: null, option?: null): UserVotedEventFilter;
        "VotingSituationCreated(string,tuple)"(name?: PromiseOrValue<string> | null, values?: null): VotingSituationCreatedEventFilter;
        VotingSituationCreated(name?: PromiseOrValue<string> | null, values?: null): VotingSituationCreatedEventFilter;
        "VotingSituationRemoved(string)"(name?: PromiseOrValue<string> | null): VotingSituationRemovedEventFilter;
        VotingSituationRemoved(name?: PromiseOrValue<string> | null): VotingSituationRemovedEventFilter;
    };
    estimateGas: {
        DAO_VOTING_RESOURCE(overrides?: CallOverrides): Promise<BigNumber>;
        PROPOSAL_EXECUTION_PERIOD(overrides?: CallOverrides): Promise<BigNumber>;
        REQUIRED_MAJORITY(overrides?: CallOverrides): Promise<BigNumber>;
        REQUIRED_QUORUM(overrides?: CallOverrides): Promise<BigNumber>;
        REQUIRED_VETO_QUORUM(overrides?: CallOverrides): Promise<BigNumber>;
        VETO_PERIOD(overrides?: CallOverrides): Promise<BigNumber>;
        VOTING_MIN_AMOUNT(overrides?: CallOverrides): Promise<BigNumber>;
        VOTING_PERIOD(overrides?: CallOverrides): Promise<BigNumber>;
        VOTING_TARGET(overrides?: CallOverrides): Promise<BigNumber>;
        VOTING_TYPE(overrides?: CallOverrides): Promise<BigNumber>;
        __DAOVoting_init(params_: IDAOVoting.ConstructorParamsStruct, resource_: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        checkPermission(member_: PromiseOrValue<string>, permission_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        createDAOVotingSituation(conf_: IDAOVoting.InitialSituationStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        createProposal(situation_: PromiseOrValue<string>, remark_: PromiseOrValue<string>, callData_: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        daoMemberStorage(overrides?: CallOverrides): Promise<BigNumber>;
        daoParameterStorage(overrides?: CallOverrides): Promise<BigNumber>;
        daoRegistry(overrides?: CallOverrides): Promise<BigNumber>;
        daoVault(overrides?: CallOverrides): Promise<BigNumber>;
        executeProposal(proposalId_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        getInjector(overrides?: CallOverrides): Promise<BigNumber>;
        getProposal(proposalId_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        getProposalList(offset_: PromiseOrValue<BigNumberish>, limit_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        getProposalStatus(proposalId_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        getProposalVotingStats(proposalId_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        getResource(overrides?: CallOverrides): Promise<BigNumber>;
        getVotingSituationInfo(situation_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        getVotingSituations(overrides?: CallOverrides): Promise<BigNumber>;
        hasUserVetoed(arg0: PromiseOrValue<BigNumberish>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        hasUserVoted(arg0: PromiseOrValue<BigNumberish>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        permissionManager(overrides?: CallOverrides): Promise<BigNumber>;
        proposalCount(overrides?: CallOverrides): Promise<BigNumber>;
        proposals(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        removeVotingSituation(situation_: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        setDependencies(registryAddress_: PromiseOrValue<string>, data_: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        setInjector(injector_: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        targetPanel(overrides?: CallOverrides): Promise<BigNumber>;
        veto(proposalId_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        voteAgainst(proposalId_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        voteFor(proposalId_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        votingToken(overrides?: CallOverrides): Promise<BigNumber>;
    };
    populateTransaction: {
        DAO_VOTING_RESOURCE(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        PROPOSAL_EXECUTION_PERIOD(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        REQUIRED_MAJORITY(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        REQUIRED_QUORUM(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        REQUIRED_VETO_QUORUM(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        VETO_PERIOD(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        VOTING_MIN_AMOUNT(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        VOTING_PERIOD(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        VOTING_TARGET(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        VOTING_TYPE(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        __DAOVoting_init(params_: IDAOVoting.ConstructorParamsStruct, resource_: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        checkPermission(member_: PromiseOrValue<string>, permission_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        createDAOVotingSituation(conf_: IDAOVoting.InitialSituationStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        createProposal(situation_: PromiseOrValue<string>, remark_: PromiseOrValue<string>, callData_: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        daoMemberStorage(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        daoParameterStorage(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        daoRegistry(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        daoVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        executeProposal(proposalId_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        getInjector(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getProposal(proposalId_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getProposalList(offset_: PromiseOrValue<BigNumberish>, limit_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getProposalStatus(proposalId_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getProposalVotingStats(proposalId_: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getResource(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVotingSituationInfo(situation_: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getVotingSituations(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        hasUserVetoed(arg0: PromiseOrValue<BigNumberish>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        hasUserVoted(arg0: PromiseOrValue<BigNumberish>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        permissionManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        proposalCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        proposals(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        removeVotingSituation(situation_: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setDependencies(registryAddress_: PromiseOrValue<string>, data_: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setInjector(injector_: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        targetPanel(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        veto(proposalId_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        voteAgainst(proposalId_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        voteFor(proposalId_: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        votingToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}
