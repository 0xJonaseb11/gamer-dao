"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterParameter = exports.getABINameFromSituationName = exports.getParameter = exports.getDecodeData = exports.getEncodedData = exports.getParametersValue = exports.getReadableParameters = exports.getReadableParameter = exports.getParameterValue = void 0;
const ethers_1 = require("ethers");
const caster_1 = require("./caster");
const types_1 = require("../types");
const ABIImporter_1 = require("../abi/ABIImporter");
const getParameterValue = (parameter) => {
    const coder = new ethers_1.ethers.utils.AbiCoder();
    if (String(parameter.solidityType) === types_1.ParameterType.ADDRESS.toString()) {
        return coder.decode(["address"], parameter.value)[0];
    }
    else if (String(parameter.solidityType) === types_1.ParameterType.UINT256.toString()) {
        return coder.decode(["uint256"], parameter.value)[0].toString();
    }
    else if (String(parameter.solidityType) === types_1.ParameterType.STRING.toString()) {
        return coder.decode(["string"], parameter.value)[0];
    }
    else if (String(parameter.solidityType) === types_1.ParameterType.BYTES.toString()) {
        return parameter.value;
    }
    else if (String(parameter.solidityType) === types_1.ParameterType.BOOL.toString()) {
        return coder.decode(["bool"], parameter.value)[0];
    }
    throw new Error("Parameter type not supported");
};
exports.getParameterValue = getParameterValue;
const getReadableParameter = (parameter) => {
    parameter.value = (0, exports.getParameterValue)(parameter);
    return parameter;
};
exports.getReadableParameter = getReadableParameter;
const getReadableParameters = (parameters) => {
    return parameters.map((parameter) => {
        return (0, exports.getReadableParameter)(parameter);
    });
};
exports.getReadableParameters = getReadableParameters;
const getParametersValue = (parameters) => {
    return parameters.map((parameter) => {
        return (0, exports.getParameterValue)(parameter);
    });
};
exports.getParametersValue = getParametersValue;
const getEncodedData = (abiName, name, ...args) => {
    const contractInterface = (0, ABIImporter_1.getEthersInterface)(`${abiName}.json`);
    return contractInterface.encodeFunctionData(name, [...args]);
};
exports.getEncodedData = getEncodedData;
const getDecodeData = (abiName, calldata) => {
    const contractInterface = (0, ABIImporter_1.getEthersInterface)(`${abiName}.json`);
    const decodedData = contractInterface.parseTransaction({ data: calldata, value: 0 });
    return {
        functionName: decodedData.name,
        arguments: filterDecodedData((0, caster_1.cast)(Object.assign({}, decodedData.args))),
    };
};
exports.getDecodeData = getDecodeData;
function filterDecodedData(rawObject) {
    if (rawObject.parameters_ === undefined && rawObject.parameter_ === undefined) {
        return rawObject;
    }
    return rawObject.parameters_
        ? (0, exports.getReadableParameters)(rawObject.parameters_)
        : (0, exports.getReadableParameter)(rawObject.parameter_);
}
function getParameter(name, value, type) {
    const parameter = {
        name: name,
        value: "",
        solidityType: type,
    };
    const coder = new ethers_1.ethers.utils.AbiCoder();
    if (type === types_1.ParameterType.ADDRESS) {
        parameter.value = coder.encode(["address"], [value]);
        return parameter;
    }
    else if (type === types_1.ParameterType.UINT256) {
        parameter.value = coder.encode(["uint256"], [value]);
        return parameter;
    }
    else if (type === types_1.ParameterType.STRING) {
        parameter.value = coder.encode(["string"], [value]);
        return parameter;
    }
    else if (type === types_1.ParameterType.BYTES) {
        parameter.value = value;
        return parameter;
    }
    else if (type === types_1.ParameterType.BOOL) {
        parameter.value = coder.encode(["bool"], [value]);
        return parameter;
    }
    return parameter;
}
exports.getParameter = getParameter;
const getABINameFromSituationName = (situationName) => {
    switch (situationName) {
        case "GeneralSituation":
            return "DAOVoting";
        case "ParameterSituation":
            return "DAOParameterStorage";
        case "MembershipSituation":
            return "DAOMemberStorage";
        case "ConstitutionSituation":
            return "DAOParameterStorage";
        default:
            return null;
    }
};
exports.getABINameFromSituationName = getABINameFromSituationName;
const filterParameter = (parameters, type, name = "") => {
    return parameters.filter((parameter) => {
        if (String(parameter.solidityType) === String(types_1.ParameterType.NONE)) {
            return parameter.name === name;
        }
        if (name === "") {
            return String(parameter.solidityType) === type.toString();
        }
        return String(parameter.solidityType) === type.toString() && parameter.name === name;
    });
};
exports.filterParameter = filterParameter;
//# sourceMappingURL=create-proposal-helper.js.map