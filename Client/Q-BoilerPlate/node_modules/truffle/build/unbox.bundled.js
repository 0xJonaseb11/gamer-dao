#!/usr/bin/env node

/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 712840:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var once = __webpack_require__(130778);

var noop = function() {};

var isRequest = function(stream) {
	return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function(stream) {
	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
};

var eos = function(stream, opts, callback) {
	if (typeof opts === 'function') return eos(stream, null, opts);
	if (!opts) opts = {};

	callback = once(callback || noop);

	var ws = stream._writableState;
	var rs = stream._readableState;
	var readable = opts.readable || (opts.readable !== false && stream.readable);
	var writable = opts.writable || (opts.writable !== false && stream.writable);
	var cancelled = false;

	var onlegacyfinish = function() {
		if (!stream.writable) onfinish();
	};

	var onfinish = function() {
		writable = false;
		if (!readable) callback.call(stream);
	};

	var onend = function() {
		readable = false;
		if (!writable) callback.call(stream);
	};

	var onexit = function(exitCode) {
		callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
	};

	var onerror = function(err) {
		callback.call(stream, err);
	};

	var onclose = function() {
		process.nextTick(onclosenexttick);
	};

	var onclosenexttick = function() {
		if (cancelled) return;
		if (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error('premature close'));
		if (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error('premature close'));
	};

	var onrequest = function() {
		stream.req.on('finish', onfinish);
	};

	if (isRequest(stream)) {
		stream.on('complete', onfinish);
		stream.on('abort', onclose);
		if (stream.req) onrequest();
		else stream.on('request', onrequest);
	} else if (writable && !ws) { // legacy streams
		stream.on('end', onlegacyfinish);
		stream.on('close', onlegacyfinish);
	}

	if (isChildProcess(stream)) stream.on('exit', onexit);

	stream.on('end', onend);
	stream.on('finish', onfinish);
	if (opts.error !== false) stream.on('error', onerror);
	stream.on('close', onclose);

	return function() {
		cancelled = true;
		stream.removeListener('complete', onfinish);
		stream.removeListener('abort', onclose);
		stream.removeListener('request', onrequest);
		if (stream.req) stream.req.removeListener('finish', onfinish);
		stream.removeListener('end', onlegacyfinish);
		stream.removeListener('close', onlegacyfinish);
		stream.removeListener('finish', onfinish);
		stream.removeListener('exit', onexit);
		stream.removeListener('end', onend);
		stream.removeListener('error', onerror);
		stream.removeListener('close', onclose);
	};
};

module.exports = eos;


/***/ }),

/***/ 299915:
/***/ ((__unused_webpack_module, exports) => {

exports.parse = exports.decode = decode

exports.stringify = exports.encode = encode

exports.safe = safe
exports.unsafe = unsafe

var eol = typeof process !== 'undefined' &&
  process.platform === 'win32' ? '\r\n' : '\n'

function encode (obj, opt) {
  var children = []
  var out = ''

  if (typeof opt === 'string') {
    opt = {
      section: opt,
      whitespace: false,
    }
  } else {
    opt = opt || Object.create(null)
    opt.whitespace = opt.whitespace === true
  }

  var separator = opt.whitespace ? ' = ' : '='

  Object.keys(obj).forEach(function (k, _, __) {
    var val = obj[k]
    if (val && Array.isArray(val)) {
      val.forEach(function (item) {
        out += safe(k + '[]') + separator + safe(item) + '\n'
      })
    } else if (val && typeof val === 'object')
      children.push(k)
    else
      out += safe(k) + separator + safe(val) + eol
  })

  if (opt.section && out.length)
    out = '[' + safe(opt.section) + ']' + eol + out

  children.forEach(function (k, _, __) {
    var nk = dotSplit(k).join('\\.')
    var section = (opt.section ? opt.section + '.' : '') + nk
    var child = encode(obj[k], {
      section: section,
      whitespace: opt.whitespace,
    })
    if (out.length && child.length)
      out += eol

    out += child
  })

  return out
}

function dotSplit (str) {
  return str.replace(/\1/g, '\u0002LITERAL\\1LITERAL\u0002')
    .replace(/\\\./g, '\u0001')
    .split(/\./).map(function (part) {
      return part.replace(/\1/g, '\\.')
        .replace(/\2LITERAL\\1LITERAL\2/g, '\u0001')
    })
}

function decode (str) {
  var out = Object.create(null)
  var p = out
  var section = null
  //          section     |key      = value
  var re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i
  var lines = str.split(/[\r\n]+/g)

  lines.forEach(function (line, _, __) {
    if (!line || line.match(/^\s*[;#]/))
      return
    var match = line.match(re)
    if (!match)
      return
    if (match[1] !== undefined) {
      section = unsafe(match[1])
      if (section === '__proto__') {
        // not allowed
        // keep parsing the section, but don't attach it.
        p = Object.create(null)
        return
      }
      p = out[section] = out[section] || Object.create(null)
      return
    }
    var key = unsafe(match[2])
    if (key === '__proto__')
      return
    var value = match[3] ? unsafe(match[4]) : true
    switch (value) {
      case 'true':
      case 'false':
      case 'null': value = JSON.parse(value)
    }

    // Convert keys with '[]' suffix to an array
    if (key.length > 2 && key.slice(-2) === '[]') {
      key = key.substring(0, key.length - 2)
      if (key === '__proto__')
        return
      if (!p[key])
        p[key] = []
      else if (!Array.isArray(p[key]))
        p[key] = [p[key]]
    }

    // safeguard against resetting a previously defined
    // array by accidentally forgetting the brackets
    if (Array.isArray(p[key]))
      p[key].push(value)
    else
      p[key] = value
  })

  // {a:{y:1},"a.b":{x:2}} --> {a:{y:1,b:{x:2}}}
  // use a filter to return the keys that have to be deleted.
  Object.keys(out).filter(function (k, _, __) {
    if (!out[k] ||
      typeof out[k] !== 'object' ||
      Array.isArray(out[k]))
      return false

    // see if the parent section is also an object.
    // if so, add it to that, and mark this one for deletion
    var parts = dotSplit(k)
    var p = out
    var l = parts.pop()
    var nl = l.replace(/\\\./g, '.')
    parts.forEach(function (part, _, __) {
      if (part === '__proto__')
        return
      if (!p[part] || typeof p[part] !== 'object')
        p[part] = Object.create(null)
      p = p[part]
    })
    if (p === out && nl === l)
      return false

    p[nl] = out[k]
    return true
  }).forEach(function (del, _, __) {
    delete out[del]
  })

  return out
}

function isQuoted (val) {
  return (val.charAt(0) === '"' && val.slice(-1) === '"') ||
    (val.charAt(0) === "'" && val.slice(-1) === "'")
}

function safe (val) {
  return (typeof val !== 'string' ||
    val.match(/[=\r\n]/) ||
    val.match(/^\[/) ||
    (val.length > 1 &&
     isQuoted(val)) ||
    val !== val.trim())
    ? JSON.stringify(val)
    : val.replace(/;/g, '\\;').replace(/#/g, '\\#')
}

function unsafe (val, doUnesc) {
  val = (val || '').trim()
  if (isQuoted(val)) {
    // remove the single quotes before calling JSON.parse
    if (val.charAt(0) === "'")
      val = val.substr(1, val.length - 2)

    try {
      val = JSON.parse(val)
    } catch (_) {}
  } else {
    // walk the val to find the first not-escaped ; character
    var esc = false
    var unesc = ''
    for (var i = 0, l = val.length; i < l; i++) {
      var c = val.charAt(i)
      if (esc) {
        if ('\\;#'.indexOf(c) !== -1)
          unesc += c
        else
          unesc += '\\' + c

        esc = false
      } else if (';#'.indexOf(c) !== -1)
        break
      else if (c === '\\')
        esc = true
      else
        unesc += c
    }
    if (esc)
      unesc += '\\'

    return unesc.trim()
  }
  return val
}


/***/ }),

/***/ 3196:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 3196;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 212352:
/***/ ((module) => {

"use strict";


var processFn = function (fn, P, opts) {
	return function () {
		var that = this;
		var args = new Array(arguments.length);

		for (var i = 0; i < arguments.length; i++) {
			args[i] = arguments[i];
		}

		return new P(function (resolve, reject) {
			args.push(function (err, result) {
				if (err) {
					reject(err);
				} else if (opts.multiArgs) {
					var results = new Array(arguments.length - 1);

					for (var i = 1; i < arguments.length; i++) {
						results[i - 1] = arguments[i];
					}

					resolve(results);
				} else {
					resolve(result);
				}
			});

			fn.apply(that, args);
		});
	};
};

var pify = module.exports = function (obj, P, opts) {
	if (typeof P !== 'function') {
		opts = P;
		P = Promise;
	}

	opts = opts || {};
	opts.exclude = opts.exclude || [/.+Sync$/];

	var filter = function (key) {
		var match = function (pattern) {
			return typeof pattern === 'string' ? key === pattern : pattern.test(key);
		};

		return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
	};

	var ret = typeof obj === 'function' ? function () {
		if (opts.excludeMain) {
			return obj.apply(this, arguments);
		}

		return processFn(obj, P, opts).apply(this, arguments);
	} : {};

	return Object.keys(obj).reduce(function (ret, key) {
		var x = obj[key];

		ret[key] = typeof x === 'function' && filter(key) ? processFn(x, P, opts) : x;

		return ret;
	}, ret);
};

pify.all = pify;


/***/ }),

/***/ 132818:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = typeof Promise === 'function' ? Promise : __webpack_require__(778555);


/***/ }),

/***/ 778555:
/***/ ((module) => {

"use strict";


var PENDING = 'pending';
var SETTLED = 'settled';
var FULFILLED = 'fulfilled';
var REJECTED = 'rejected';
var NOOP = function () {};
var isNode = typeof global !== 'undefined' && typeof global.process !== 'undefined' && typeof global.process.emit === 'function';

var asyncSetTimer = typeof setImmediate === 'undefined' ? setTimeout : setImmediate;
var asyncQueue = [];
var asyncTimer;

function asyncFlush() {
	// run promise callbacks
	for (var i = 0; i < asyncQueue.length; i++) {
		asyncQueue[i][0](asyncQueue[i][1]);
	}

	// reset async asyncQueue
	asyncQueue = [];
	asyncTimer = false;
}

function asyncCall(callback, arg) {
	asyncQueue.push([callback, arg]);

	if (!asyncTimer) {
		asyncTimer = true;
		asyncSetTimer(asyncFlush, 0);
	}
}

function invokeResolver(resolver, promise) {
	function resolvePromise(value) {
		resolve(promise, value);
	}

	function rejectPromise(reason) {
		reject(promise, reason);
	}

	try {
		resolver(resolvePromise, rejectPromise);
	} catch (e) {
		rejectPromise(e);
	}
}

function invokeCallback(subscriber) {
	var owner = subscriber.owner;
	var settled = owner._state;
	var value = owner._data;
	var callback = subscriber[settled];
	var promise = subscriber.then;

	if (typeof callback === 'function') {
		settled = FULFILLED;
		try {
			value = callback(value);
		} catch (e) {
			reject(promise, e);
		}
	}

	if (!handleThenable(promise, value)) {
		if (settled === FULFILLED) {
			resolve(promise, value);
		}

		if (settled === REJECTED) {
			reject(promise, value);
		}
	}
}

function handleThenable(promise, value) {
	var resolved;

	try {
		if (promise === value) {
			throw new TypeError('A promises callback cannot return that same promise.');
		}

		if (value && (typeof value === 'function' || typeof value === 'object')) {
			// then should be retrieved only once
			var then = value.then;

			if (typeof then === 'function') {
				then.call(value, function (val) {
					if (!resolved) {
						resolved = true;

						if (value === val) {
							fulfill(promise, val);
						} else {
							resolve(promise, val);
						}
					}
				}, function (reason) {
					if (!resolved) {
						resolved = true;

						reject(promise, reason);
					}
				});

				return true;
			}
		}
	} catch (e) {
		if (!resolved) {
			reject(promise, e);
		}

		return true;
	}

	return false;
}

function resolve(promise, value) {
	if (promise === value || !handleThenable(promise, value)) {
		fulfill(promise, value);
	}
}

function fulfill(promise, value) {
	if (promise._state === PENDING) {
		promise._state = SETTLED;
		promise._data = value;

		asyncCall(publishFulfillment, promise);
	}
}

function reject(promise, reason) {
	if (promise._state === PENDING) {
		promise._state = SETTLED;
		promise._data = reason;

		asyncCall(publishRejection, promise);
	}
}

function publish(promise) {
	promise._then = promise._then.forEach(invokeCallback);
}

function publishFulfillment(promise) {
	promise._state = FULFILLED;
	publish(promise);
}

function publishRejection(promise) {
	promise._state = REJECTED;
	publish(promise);
	if (!promise._handled && isNode) {
		global.process.emit('unhandledRejection', promise._data, promise);
	}
}

function notifyRejectionHandled(promise) {
	global.process.emit('rejectionHandled', promise);
}

/**
 * @class
 */
function Promise(resolver) {
	if (typeof resolver !== 'function') {
		throw new TypeError('Promise resolver ' + resolver + ' is not a function');
	}

	if (this instanceof Promise === false) {
		throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
	}

	this._then = [];

	invokeResolver(resolver, this);
}

Promise.prototype = {
	constructor: Promise,

	_state: PENDING,
	_then: null,
	_data: undefined,
	_handled: false,

	then: function (onFulfillment, onRejection) {
		var subscriber = {
			owner: this,
			then: new this.constructor(NOOP),
			fulfilled: onFulfillment,
			rejected: onRejection
		};

		if ((onRejection || onFulfillment) && !this._handled) {
			this._handled = true;
			if (this._state === REJECTED && isNode) {
				asyncCall(notifyRejectionHandled, this);
			}
		}

		if (this._state === FULFILLED || this._state === REJECTED) {
			// already resolved, call callback async
			asyncCall(invokeCallback, subscriber);
		} else {
			// subscribe
			this._then.push(subscriber);
		}

		return subscriber.then;
	},

	catch: function (onRejection) {
		return this.then(null, onRejection);
	}
};

Promise.all = function (promises) {
	if (!Array.isArray(promises)) {
		throw new TypeError('You must pass an array to Promise.all().');
	}

	return new Promise(function (resolve, reject) {
		var results = [];
		var remaining = 0;

		function resolver(index) {
			remaining++;
			return function (value) {
				results[index] = value;
				if (!--remaining) {
					resolve(results);
				}
			};
		}

		for (var i = 0, promise; i < promises.length; i++) {
			promise = promises[i];

			if (promise && typeof promise.then === 'function') {
				promise.then(resolver(i), reject);
			} else {
				results[i] = promise;
			}
		}

		if (!remaining) {
			resolve(results);
		}
	});
};

Promise.race = function (promises) {
	if (!Array.isArray(promises)) {
		throw new TypeError('You must pass an array to Promise.race().');
	}

	return new Promise(function (resolve, reject) {
		for (var i = 0, promise; i < promises.length; i++) {
			promise = promises[i];

			if (promise && typeof promise.then === 'function') {
				promise.then(resolve, reject);
			} else {
				resolve(promise);
			}
		}
	});
};

Promise.resolve = function (value) {
	if (value && typeof value === 'object' && value.constructor === Promise) {
		return value;
	}

	return new Promise(function (resolve) {
		resolve(value);
	});
};

Promise.reject = function (reason) {
	return new Promise(function (resolve, reject) {
		reject(reason);
	});
};

module.exports = Promise;


/***/ }),

/***/ 72995:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(591283),
  meta: __webpack_require__(474292)
};


/***/ }),

/***/ 474292:
/***/ ((module) => {

module.exports = {
  command: "unbox",
  description: "Download a Truffle Box, a pre-built Truffle project",
  builder: {},
  help: {
    usage: "truffle unbox [<box_name>] [destination] [--force]",
    options: [
      {
        option: "destination",
        description:
          "Path to the directory in which you would like " +
          "to unbox the project files. If destination is\n                  " +
          "  not provided, this defaults to the current directory."
      },
      {
        option: "<box_name>",
        description:
          "Name of the truffle box. If no box_name is specified, a default " +
          "truffle box will be downloaded."
      },
      {
        option: "--force",
        description:
          "Unbox project in the current directory regardless of its " +
          "state. Be careful, this\n                    will potentially overwrite files " +
          "that exist in the directory."
      }
    ],
    allowedGlobalOptions: ["quiet"]
  }
};


/***/ }),

/***/ 591283:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const normalizeDestination = (destination, workingDirectory) => {
  if (!destination) {
    return workingDirectory;
  }
  const path = __webpack_require__(371017);
  if (path.isAbsolute(destination)) return destination;
  return path.join(workingDirectory, destination);
};

module.exports = async options => {
  const Config = __webpack_require__(120553);
  const { default: Box } = __webpack_require__(221579);
  const fse = __webpack_require__(655674);

  const config = Config.default().with({ logger: console });
  // we merge in the options so that options passed on the command line
  // (for example --quiet) make it to the EventManager
  config.merge(options);

  let [url, destination] = options._;

  const normalizedDestination = normalizeDestination(
    destination,
    config.working_directory
  );

  fse.ensureDirSync(normalizedDestination);

  const unboxOptions = Object.assign({}, options, { logger: config.logger });

  config.events.emit("unbox:start");

  const boxConfig = await Box.unbox(
    url,
    normalizedDestination,
    unboxOptions,
    config
  );
  await config.events.emit("unbox:succeed", { boxConfig });
};


/***/ }),

/***/ 221579:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.normalizeSourcePath = void 0;
const utils_1 = __importDefault(__webpack_require__(326086));
const tmp_1 = __importDefault(__webpack_require__(336276));
const path_1 = __importDefault(__webpack_require__(371017));
const config_1 = __importDefault(__webpack_require__(120553));
const fs_extra_1 = __importDefault(__webpack_require__(655674));
const inquirer_1 = __importDefault(__webpack_require__(496062));
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = (0, debug_1.default)("unbox");
const defaultPath = "git@github.com:trufflesuite/truffle-init-default";
/*
 * accepts a number of different url and org/repo formats and returns the
 * format required by https://www.npmjs.com/package/download-git-repo for remote URLs
 * or absolute path to local folder if the source is local folder
 *
 * supported input formats are as follows:
 *   - org/repo[#branch]
 *   - https://github.com(/|:)<org>/<repo>[.git][#branch]
 *   - git@github.com:<org>/<repo>[#branch]
 *   - path to local folder (absolute, relative or ~/home)
 */
const normalizeSourcePath = (url = defaultPath) => {
    // Process filepath resolution
    //
    if (url.startsWith(".") || url.startsWith("/") || url.startsWith("~")) {
        debug({ in: url, out: path_1.default.normalize(url) });
        return path_1.default.resolve(path_1.default.normalize(url));
    }
    // preprocess to reduce regex complexity
    // `https` is not case sensitiv, unlike `git`
    url = url.replace(/^https/i, "https");
    // branch should not end with slash
    const invalidBranch = /\/$/;
    // process https? or git prefixed input
    //
    if (/^(https?|git)/i.test(url)) {
        // This regular expression uses named capture groups to parse input. The
        // format is (?<the-name>the-regex)
        //
        // \w, the word meta character is a member of [A-Za-z0-9_]. all letters,
        // digits and the underscore. Note \w has to be \\w to escape the backslash
        // in a string literal.
        //
        const protocolRex = new RegExp([
            // match either `htps://` or `git@`
            "(?<protocol>(https://|git@))",
            // service is 1 or many (word, dot or dash)
            "(?<service>[\\w.-]+)",
            // match either `/` or `:`
            "(/|:)",
            // org is 1 or many (word, dot or dash)
            "(?<org>[\\w.-]+)",
            "/",
            // repo is 1 or many (word, dot or dash)
            "(?<repo>[\\w.-]+)",
            // branch is 1 or many (word, dot or dash) and can be optional
            "(?<branch>#[\\w./-]+)?",
            // the input string must be consumed fully at this point to match
            "$"
        ].join(""));
        const match = url.match(protocolRex);
        if (match) {
            const { groups } = match;
            const branch = groups["branch"] || "";
            if (invalidBranch.test(branch)) {
                debug({
                    in: url,
                    error: "InvalidFormat (protocol)",
                    hint: "branch is malformed"
                });
                throw new Error("Box specified with invalid format (git/https)");
            }
            const repo = groups["repo"].replace(/\.git$/i, "");
            const result = `https://${groups["service"]}:${groups["org"]}/${repo}${branch}`;
            debug({ in: url, out: result });
            return result;
        }
        debug({
            in: url,
            error: "InvalidFormat (protocol)",
            hint: "did not match protocol"
        });
        throw new Error("Box specified with invalid format (git/https)");
    }
    // default case: process [org/] + repo + [ #branch/name/with/slashes ]
    //
    const orgRepoBranchRex = new RegExp([
        // start match at beginning
        "^",
        // org is 1 or many (word, dot or dash) followed by a slash. org can be
        // optional
        "(?<org>[\\w.-]+/)?",
        // repo is 1 or many (word, dot or dash)
        "(?<repo>[\\w.-]+)",
        // optional branch (undefined if unmatched)
        "(?<branch>#[\\w./-]+)?",
        "$"
    ].join(""));
    const match = url.match(orgRepoBranchRex);
    if (match) {
        const { groups } = match;
        // `truffle-box` is the default org
        const org = groups["org"] || "truffle-box/";
        const branch = groups["branch"] || "";
        if (invalidBranch.test(branch)) {
            debug({
                in: url,
                error: "InvalidFormat (orgRepoBranch)",
                hint: "branch is malformed"
            });
            throw new Error("Box specified with invalid format");
        }
        let repo = groups["repo"];
        // Official Truffle boxes should have a `-box` suffix
        if (org.toLowerCase().startsWith("truffle-box")) {
            repo = repo.endsWith("-box") ? repo : `${repo}-box`;
        }
        const result = `https://github.com:${org}${repo}${branch}`;
        debug({ in: url, out: result });
        return result;
    }
    // No match, it's an error!
    debug({ in: url, error: "InvalidFormat", hint: "matched nothing" });
    throw new Error("Box specified in invalid format");
};
exports.normalizeSourcePath = normalizeSourcePath;
const parseSandboxOptions = (options) => {
    if (typeof options === "string") {
        // back compatibility for when `options` used to be `name`
        return {
            name: options,
            unsafeCleanup: false,
            setGracefulCleanup: false,
            logger: console,
            force: false
        };
    }
    else if (typeof options === "object") {
        return {
            name: options.name || "default",
            unsafeCleanup: options.unsafeCleanup || false,
            setGracefulCleanup: options.setGracefulCleanup || false,
            logger: options.logger || console,
            force: options.force || false
        };
    }
};
const Box = {
    unbox: (url, destination, options = {}, config) => __awaiter(void 0, void 0, void 0, function* () {
        const { events } = config;
        let tempDirCleanup;
        const unpackBoxOptions = {
            logger: options.logger,
            force: options.force
        };
        try {
            const normalizedSourcePath = (0, exports.normalizeSourcePath)(url);
            yield Box.checkDir(options, destination);
            const tempDir = utils_1.default.setUpTempDirectory(events);
            const tempDirPath = tempDir.path;
            tempDirCleanup = tempDir.cleanupCallback;
            yield utils_1.default.downloadBox(normalizedSourcePath, tempDirPath, events);
            const boxConfig = yield utils_1.default.readBoxConfig(tempDirPath);
            yield utils_1.default.unpackBox(tempDirPath, destination, boxConfig, unpackBoxOptions);
            events.emit("unbox:cleaningTempFiles:start");
            tempDirCleanup();
            events.emit("unbox:cleaningTempFiles:succeed");
            utils_1.default.setUpBox(boxConfig, destination, events);
            return boxConfig;
        }
        catch (error) {
            if (tempDirCleanup)
                tempDirCleanup();
            events.emit("unbox:fail");
            throw error;
        }
    }),
    checkDir: (options = {}, destination) => __awaiter(void 0, void 0, void 0, function* () {
        let logger = options.logger || console;
        if (!options.force) {
            const unboxDir = fs_extra_1.default.readdirSync(destination);
            if (unboxDir.length) {
                logger.log(`This directory is non-empty...`);
                const prompt = [
                    {
                        type: "confirm",
                        name: "proceed",
                        message: `Proceed anyway?`,
                        default: true
                    }
                ];
                const answer = yield inquirer_1.default.prompt(prompt);
                if (!answer.proceed) {
                    logger.log("Unbox cancelled");
                    process.exit();
                }
            }
        }
    }),
    // options.unsafeCleanup
    //   Recursively removes the created temporary directory, even when it's not empty. default is false
    // options.setGracefulCleanup
    //   Cleanup temporary files even when an uncaught exception occurs
    sandbox: (options) => __awaiter(void 0, void 0, void 0, function* () {
        const { name, unsafeCleanup, setGracefulCleanup, logger, force } = parseSandboxOptions(options);
        const boxPath = name.replace(/^default(?=#|$)/, defaultPath);
        //ordinarily, this line will have no effect.  however, if the name is "default",
        //possibly with a branch specification, this replaces it appropriately
        //(this is necessary in order to keep using trufflesuite/truffle-init-default
        //instead of truffle-box/etc)
        if (setGracefulCleanup)
            tmp_1.default.setGracefulCleanup();
        let config = new config_1.default();
        const tmpDir = tmp_1.default.dirSync({ unsafeCleanup });
        const unboxOptions = { logger, force };
        yield Box.unbox(boxPath, tmpDir.name, unboxOptions, config);
        return config_1.default.load(path_1.default.join(tmpDir.name, "truffle-config.js"), {});
    })
};
exports["default"] = Box;
//# sourceMappingURL=box.js.map

/***/ }),

/***/ 77220:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const fs_extra_1 = __importDefault(__webpack_require__(655674));
function setDefaults(config = {}) {
    const hooks = config.hooks || {};
    return {
        ignore: config.ignore || [],
        commands: config.commands || {
            compile: "truffle compile",
            migrate: "truffle migrate",
            test: "truffle test"
        },
        hooks: {
            "post-unpack": hooks["post-unpack"] || ""
        }
    };
}
function read(path) {
    return fs_extra_1.default
        .readFile(path)
        .catch(() => "{}")
        .then(JSON.parse)
        .then(setDefaults);
}
module.exports = {
    read,
    setDefaults
};
//# sourceMappingURL=config.js.map

/***/ }),

/***/ 326086:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const unbox_1 = __importDefault(__webpack_require__(91104));
const fs_1 = __importDefault(__webpack_require__(657147));
const config_1 = __importDefault(__webpack_require__(77220));
const tmp_1 = __importDefault(__webpack_require__(336276));
const path_1 = __importDefault(__webpack_require__(371017));
module.exports = {
    downloadBox: (source, destination, events) => __awaiter(void 0, void 0, void 0, function* () {
        events.emit("unbox:downloadingBox:start");
        yield unbox_1.default.verifySourcePath(source);
        yield unbox_1.default.fetchRepository(source, destination);
        events.emit("unbox:downloadingBox:succeed");
    }),
    readBoxConfig: (destination) => __awaiter(void 0, void 0, void 0, function* () {
        const possibleConfigs = [
            path_1.default.join(destination, "truffle-box.json"),
            path_1.default.join(destination, "truffle-init.json")
        ];
        const configPath = possibleConfigs.reduce((path, alt) => path || (fs_1.default.existsSync(alt) && alt), undefined);
        return yield config_1.default.read(configPath);
    }),
    setUpTempDirectory: (events) => {
        events.emit("unbox:preparingToDownload:start");
        const options = {
            unsafeCleanup: true
        };
        const tmpDir = tmp_1.default.dirSync(options);
        events.emit("unbox:preparingToDownload:succeed");
        return {
            path: path_1.default.join(tmpDir.name, "box"),
            cleanupCallback: tmpDir.removeCallback
        };
    },
    unpackBox: (tempDir, destination, boxConfig, unpackBoxOptions) => __awaiter(void 0, void 0, void 0, function* () {
        unbox_1.default.prepareToCopyFiles(tempDir, boxConfig);
        yield unbox_1.default.copyTempIntoDestination(tempDir, destination, unpackBoxOptions);
    }),
    setUpBox: (boxConfig, destination, events) => {
        events.emit("unbox:settingUpBox:start");
        unbox_1.default.installBoxDependencies(boxConfig, destination);
        events.emit("unbox:settingUpBox:succeed");
    }
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 91104:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const fs_extra_1 = __importDefault(__webpack_require__(655674));
const path_1 = __importDefault(__webpack_require__(371017));
const download_git_repo_1 = __importDefault(__webpack_require__(120448));
const axios_1 = __importDefault(__webpack_require__(743306));
const vcsurl_1 = __importDefault(__webpack_require__(309627));
const url_1 = __webpack_require__(257310);
const child_process_1 = __webpack_require__(532081);
const inquirer_1 = __importDefault(__webpack_require__(496062));
const util_1 = __webpack_require__(473837);
const ignore_1 = __importDefault(__webpack_require__(754877));
function verifyLocalPath(localPath) {
    const configPath = path_1.default.join(localPath, "truffle-box.json");
    fs_extra_1.default.access(configPath).catch(_e => {
        throw new Error(`Truffle Box at path ${localPath} doesn't exist.`);
    });
}
function verifyVCSURL(url) {
    return __awaiter(this, void 0, void 0, function* () {
        // Next let's see if the expected repository exists. If it doesn't, ghdownload
        // will fail spectacularly in a way we can't catch, so we have to do it ourselves.
        const configURL = (0, url_1.parse)(`${(0, vcsurl_1.default)(url)
            .replace("github.com", "raw.githubusercontent.com")
            .replace(/#.*/, "")}/master/truffle-box.json`);
        const repoUrl = `https://${configURL.host}${configURL.path}`;
        try {
            yield axios_1.default.head(repoUrl, { maxRedirects: 50 });
        }
        catch (error) {
            if (error.response && error.response.status === 404) {
                throw new Error(`Truffle Box at URL ${url} doesn't exist. If you believe this is an error, please contact Truffle support.`);
            }
            else {
                const prefix = `Error connecting to ${repoUrl}. Please check your internet connection and try again.`;
                error.message = `${prefix}\n\n${error.message || ""}`;
                throw error;
            }
        }
    });
}
function verifySourcePath(sourcePath) {
    return __awaiter(this, void 0, void 0, function* () {
        if (sourcePath.startsWith("/")) {
            return verifyLocalPath(sourcePath);
        }
        return verifyVCSURL(sourcePath);
    });
}
function gitIgnoreFilter(sourcePath) {
    return __awaiter(this, void 0, void 0, function* () {
        const ignoreFilter = (0, ignore_1.default)();
        try {
            const gitIgnore = yield fs_extra_1.default.readFile(path_1.default.join(sourcePath, ".gitignore"), "utf8");
            ignoreFilter.add(gitIgnore.split(/\r?\n/).map(p => p.replace(/\/$/, "")));
        }
        catch (err) { }
        return ignoreFilter;
    });
}
function fetchRepository(sourcePath, dir) {
    return __awaiter(this, void 0, void 0, function* () {
        if (sourcePath.startsWith("/")) {
            const filter = yield gitIgnoreFilter(sourcePath);
            return fs_extra_1.default.copy(sourcePath, dir, {
                filter: file => sourcePath === file || !filter.ignores(path_1.default.relative(sourcePath, file))
            });
        }
        return (0, util_1.promisify)(download_git_repo_1.default)(sourcePath, dir);
    });
}
function prepareToCopyFiles(tempDir, { ignore }) {
    const needingRemoval = ignore;
    // remove box config file
    needingRemoval.push("truffle-box.json");
    needingRemoval.push("truffle-init.json");
    needingRemoval
        .map((fileName) => path_1.default.join(tempDir, fileName))
        .forEach((filePath) => fs_extra_1.default.removeSync(filePath));
}
function promptOverwrites(contentCollisions, logger = console) {
    return __awaiter(this, void 0, void 0, function* () {
        const overwriteContents = [];
        for (const file of contentCollisions) {
            logger.log(`${file} already exists in this directory...`);
            const overwriting = [
                {
                    type: "confirm",
                    name: "overwrite",
                    message: `Overwrite ${file}?`,
                    default: false
                }
            ];
            const { overwrite } = yield inquirer_1.default.prompt(overwriting);
            if (overwrite) {
                fs_extra_1.default.removeSync(file);
                overwriteContents.push(file);
            }
        }
        return overwriteContents;
    });
}
function copyTempIntoDestination(tmpDir, destination, options) {
    return __awaiter(this, void 0, void 0, function* () {
        fs_extra_1.default.ensureDirSync(destination);
        const { force, logger } = options;
        const boxContents = fs_extra_1.default.readdirSync(tmpDir);
        const destinationContents = fs_extra_1.default.readdirSync(destination);
        const newContents = boxContents.filter(filename => !destinationContents.includes(filename));
        const contentCollisions = boxContents.filter(filename => destinationContents.includes(filename));
        let shouldCopy;
        if (force) {
            shouldCopy = boxContents;
        }
        else {
            const overwriteContents = yield promptOverwrites(contentCollisions, logger);
            shouldCopy = [...newContents, ...overwriteContents];
        }
        for (const file of shouldCopy) {
            fs_extra_1.default.copySync(`${tmpDir}/${file}`, `${destination}/${file}`);
        }
    });
}
function installBoxDependencies({ hooks }, destination) {
    const postUnpack = hooks["post-unpack"];
    if (postUnpack.length === 0)
        return;
    (0, child_process_1.execSync)(postUnpack, { cwd: destination });
}
module.exports = {
    copyTempIntoDestination,
    fetchRepository,
    installBoxDependencies,
    prepareToCopyFiles,
    verifySourcePath,
    verifyVCSURL
};
//# sourceMappingURL=unbox.js.map

/***/ }),

/***/ 344516:
/***/ ((module) => {

"use strict";
module.exports = require("original-require");

/***/ }),

/***/ 439491:
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ 950852:
/***/ ((module) => {

"use strict";
module.exports = require("async_hooks");

/***/ }),

/***/ 714300:
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ 532081:
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ 722057:
/***/ ((module) => {

"use strict";
module.exports = require("constants");

/***/ }),

/***/ 706113:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ 582361:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 657147:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 113685:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 795687:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 241808:
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ 822037:
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 371017:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 285477:
/***/ ((module) => {

"use strict";
module.exports = require("punycode");

/***/ }),

/***/ 863477:
/***/ ((module) => {

"use strict";
module.exports = require("querystring");

/***/ }),

/***/ 514521:
/***/ ((module) => {

"use strict";
module.exports = require("readline");

/***/ }),

/***/ 12781:
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ 371576:
/***/ ((module) => {

"use strict";
module.exports = require("string_decoder");

/***/ }),

/***/ 924404:
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ 76224:
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ 257310:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 473837:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 959796:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// the startup function
/******/ 	__webpack_require__.x = () => {
/******/ 		// Load entry module and return exports
/******/ 		var __webpack_exports__ = __webpack_require__.O(undefined, [5158,4785,3618,8074,6127,5674,6674,4914,4877,6062,6276,7724,553], () => (__webpack_require__(72995)))
/******/ 		__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 		return __webpack_exports__;
/******/ 	};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks and sibling chunks for the entrypoint
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".bundled.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/require chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "loaded", otherwise not loaded yet
/******/ 		var installedChunks = {
/******/ 			3462: 1
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.O.require = (chunkId) => (installedChunks[chunkId]);
/******/ 		
/******/ 		var installChunk = (chunk) => {
/******/ 			var moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			for(var i = 0; i < chunkIds.length; i++)
/******/ 				installedChunks[chunkIds[i]] = 1;
/******/ 			__webpack_require__.O();
/******/ 		};
/******/ 		
/******/ 		// require() chunk loading for javascript
/******/ 		__webpack_require__.f.require = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					installChunk(require("./" + __webpack_require__.u(chunkId)));
/******/ 				} else installedChunks[chunkId] = 1;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		// no external install chunk
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/startup chunk dependencies */
/******/ 	(() => {
/******/ 		var next = __webpack_require__.x;
/******/ 		__webpack_require__.x = () => {
/******/ 			__webpack_require__.e(5158);
/******/ 			__webpack_require__.e(4785);
/******/ 			__webpack_require__.e(3618);
/******/ 			__webpack_require__.e(8074);
/******/ 			__webpack_require__.e(6127);
/******/ 			__webpack_require__.e(5674);
/******/ 			__webpack_require__.e(6674);
/******/ 			__webpack_require__.e(4914);
/******/ 			__webpack_require__.e(4877);
/******/ 			__webpack_require__.e(6062);
/******/ 			__webpack_require__.e(6276);
/******/ 			__webpack_require__.e(7724);
/******/ 			__webpack_require__.e(553);
/******/ 			return next();
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// run startup
/******/ 	var __webpack_exports__ = __webpack_require__.x();
/******/ 	var __webpack_export_target__ = exports;
/******/ 	for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
/******/ 	if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ 	
/******/ })()
;
//# sourceMappingURL=unbox.bundled.js.map