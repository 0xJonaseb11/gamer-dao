"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUpgradeabilityAssessment = exports.ReferenceContractNotFound = void 0;
const annotations_1 = require("../../utils/annotations");
const query_1 = require("../../validate/query");
const error_1 = require("./error");
class ReferenceContractNotFound extends Error {
    constructor(reference, origin) {
        super(`Could not find contract ${reference} referenced in ${origin}.`);
        this.reference = reference;
        this.origin = origin;
    }
}
exports.ReferenceContractNotFound = ReferenceContractNotFound;
function getUpgradeabilityAssessment(contract, allContracts) {
    const fullContractName = contract.fullyQualifiedName;
    const contractValidation = contract.validationData[fullContractName];
    const isUUPS = (0, query_1.inferUUPS)(contract.validationData, fullContractName);
    const annotationAssessment = getAnnotationAssessment(contract);
    if (annotationAssessment.upgradeable) {
        let referenceContract = undefined;
        let isReferenceUUPS = false;
        if (annotationAssessment.referenceName !== undefined) {
            referenceContract = getReferenceContract(annotationAssessment.referenceName, contract, allContracts);
            isReferenceUUPS = (0, query_1.inferUUPS)(referenceContract.validationData, referenceContract.fullyQualifiedName);
        }
        return {
            upgradeable: true,
            referenceContract: referenceContract,
            uups: isReferenceUUPS || isUUPS,
        };
    }
    else {
        const initializable = (0, query_1.inferInitializable)(contractValidation);
        return {
            upgradeable: initializable || isUUPS,
            uups: isUUPS,
        };
    }
}
exports.getUpgradeabilityAssessment = getUpgradeabilityAssessment;
function getReferenceContract(reference, origin, allContracts) {
    const referenceContracts = allContracts.filter(c => c.fullyQualifiedName === reference || c.name === reference);
    if (referenceContracts.length > 1) {
        throw new error_1.ValidateCommandError(`Found multiple contracts with name ${reference} referenced in ${origin.fullyQualifiedName}.`, () => `This may be caused by old copies of build info files. Clean and recompile your project, then run the command again with the updated files.`);
    }
    else if (referenceContracts.length === 1) {
        return referenceContracts[0];
    }
    else {
        throw new ReferenceContractNotFound(reference, origin.fullyQualifiedName);
    }
}
function getAnnotationAssessment(contract) {
    const node = contract.node;
    if ('documentation' in node) {
        const doc = (0, annotations_1.getDocumentation)(node);
        const tag = 'oz-upgrades';
        const hasUpgradeAnnotation = hasAnnotationTag(doc, tag);
        if (hasUpgradeAnnotation) {
            getAndValidateAnnotationArgs(doc, tag, contract, 0);
        }
        const upgradesFrom = getUpgradesFrom(doc, contract);
        if (upgradesFrom !== undefined) {
            return {
                upgradeable: true,
                referenceName: upgradesFrom,
            };
        }
        else {
            return {
                upgradeable: hasUpgradeAnnotation,
            };
        }
    }
    else {
        return {
            upgradeable: false,
        };
    }
}
function getAndValidateAnnotationArgs(doc, tag, contract, expectedLength) {
    const annotationArgs = (0, annotations_1.getAnnotationArgs)(doc, tag, undefined);
    if (annotationArgs.length !== expectedLength) {
        throw new error_1.ValidateCommandError(`Invalid number of arguments for @custom:${tag} annotation in contract ${contract.fullyQualifiedName}.`, () => `Found ${annotationArgs.length}, expected ${expectedLength}.`);
    }
    return annotationArgs;
}
function hasAnnotationTag(doc, tag) {
    const regex = new RegExp(`^\\s*(@custom:${tag})(\\s|$)`, 'm');
    return regex.test(doc);
}
function getUpgradesFrom(doc, contract) {
    const tag = 'oz-upgrades-from';
    if (hasAnnotationTag(doc, tag)) {
        const annotationArgs = getAndValidateAnnotationArgs(doc, tag, contract, 1);
        return annotationArgs[0];
    }
    else {
        return undefined;
    }
}
//# sourceMappingURL=upgradeability-assessment.js.map